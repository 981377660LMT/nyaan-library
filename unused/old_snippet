{
  // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and
  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
  // same ids are connected.
  // Example:
  // "Print to console": {
  // "prefix": "log",
  // "body": [
  // "console.log('$1');",
  // "$2"
  // ],
  // "description": "Log output to console"
  // }
  "gcd_and_lcm": {
    "prefix": "_gcd",
    "body": [
      "// c++17での名前衝突を避けるためdefine",
      "#define gcd nyagcd",
      "#define lcm nyalcm",
      "ll nyagcd(ll x, ll y){",
      "  ll z;",
      "  if(x > y) swap(x,y);",
      "  while(x){",
      "    x = y % (z = x); y = z;",
      "  }    ",
      "  return y;",
      "}",
      "ll nyalcm(ll x,ll y){",
      "  return 1LL * x / gcd(x,y) * y;",
      "}"
    ],
    "description": "gcd_and_lcm"
  },
  "Matrix_struct": {
    "prefix": "_Matrix",
    "body": [
      "#define size_t int",
      "template< class T >",
      "struct Matrix {",
      "  vector< vector< T > > A;",
      "",
      "  Matrix() {}",
      "",
      "  Matrix(size_t n, size_t m) : A(n, vector< T >(m, 0)) {}",
      "",
      "  Matrix(size_t n) : A(n, vector< T >(n, 0)) {};",
      "",
      "  size_t height() const {",
      "    return (A.size());",
      "  }",
      "",
      "  size_t width() const {",
      "    return (A[0].size());",
      "  }",
      "",
      "  inline const vector< T > &operator[](int k) const {",
      "    return (A.at(k));",
      "  }",
      "",
      "  inline vector< T > &operator[](int k) {",
      "    return (A.at(k));",
      "  }",
      "",
      "  static Matrix I(size_t n) {",
      "    Matrix mat(n);",
      "    for(int i = 0; i < n; i++) mat[i][i] = 1;",
      "    return (mat);",
      "  }",
      "",
      "  Matrix &operator+=(const Matrix &B) {",
      "    size_t n = height(), m = width();",
      "    assert(n == B.height() && m == B.width());",
      "    for(int i = 0; i < n; i++)",
      "      for(int j = 0; j < m; j++)",
      "        (*this)[i][j] += B[i][j];",
      "    return (*this);",
      "  }",
      "",
      "  Matrix &operator-=(const Matrix &B) {",
      "    size_t n = height(), m = width();",
      "    assert(n == B.height() && m == B.width());",
      "    for(int i = 0; i < n; i++)",
      "      for(int j = 0; j < m; j++)",
      "        (*this)[i][j] -= B[i][j];",
      "    return (*this);",
      "  }",
      "",
      "  Matrix &operator*=(const Matrix &B) {",
      "    size_t n = height(), m = B.width(), p = width();",
      "    assert(p == B.height());",
      "    vector< vector< T > > C(n, vector< T >(m, 0));",
      "    for(int i = 0; i < n; i++)",
      "      for(int j = 0; j < m; j++)",
      "        for(int k = 0; k < p; k++)",
      "          C[i][j] = (C[i][j] + (*this)[i][k] * B[k][j]);",
      "    A.swap(C);",
      "    return (*this);",
      "  }",
      "",
      "  Matrix &operator^=(long long k) {",
      "    Matrix B = Matrix::I(height());",
      "    while(k > 0) {",
      "      if(k & 1) B *= *this;",
      "      *this *= *this;",
      "      k >>= 1LL;",
      "    }",
      "    A.swap(B.A);",
      "    return (*this);",
      "  }",
      "",
      "  Matrix operator+(const Matrix &B) const {",
      "    return (Matrix(*this) += B);",
      "  }",
      "",
      "  Matrix operator-(const Matrix &B) const {",
      "    return (Matrix(*this) -= B);",
      "  }",
      "",
      "  Matrix operator*(const Matrix &B) const {",
      "    return (Matrix(*this) *= B);",
      "  }",
      "",
      "  Matrix operator^(const long long k) const {",
      "    return (Matrix(*this) ^= k);",
      "  }",
      "",
      "  friend ostream &operator<<(ostream &os, Matrix &p) {",
      "    size_t n = p.height(), m = p.width();",
      "    for(int i = 0; i < n; i++) {",
      "      os << \"[\";",
      "      for(int j = 0; j < m; j++) {",
      "        os << p[i][j] << (j + 1 == m ? \"]\\n\" : \",\");",
      "      }",
      "    }",
      "    return (os);",
      "  }",
      "",
      "",
      "  T determinant() {",
      "    Matrix B(*this);",
      "    assert(width() == height());",
      "    T ret = 1;",
      "    for(int i = 0; i < width(); i++) {",
      "      int idx = -1;",
      "      for(int j = i; j < width(); j++) {",
      "        if(B[j][i] != 0) idx = j;",
      "      }",
      "      if(idx == -1) return (0);",
      "      if(i != idx) {",
      "        ret *= -1;",
      "        swap(B[i], B[idx]);",
      "      }",
      "      ret *= B[i][i];",
      "      T vv = B[i][i];",
      "      for(int j = 0; j < width(); j++) {",
      "        B[i][j] /= vv;",
      "      }",
      "      for(int j = i + 1; j < width(); j++) {",
      "        T a = B[j][i];",
      "        for(int k = 0; k < width(); k++) {",
      "          B[j][k] -= B[i][k] * a;",
      "        }",
      "      }",
      "    }",
      "    return (ret);",
      "  }",
      "};"
    ],
    "description": "Matrix_struct"
  },
  "pow": {
    "prefix": "_pow",
    "body": [
      "",
      "#define pow nyapow",
      "inline ll nyapow(ll b,ll n){",
      "  ll ret = 1;",
      "  while(n){",
      "    if(n & 1) ret *= b;",
      "    b *= b;",
      "    n >>= 1;",
      "  }",
      "  return ret;",
      "}"
    ],
    "description": "pow"
  },
  "Random_Number_Generator": {
    "prefix": "_rng",
    "body": [
      "auto rand_time = chrono::duration_cast<chrono::nanoseconds>(chrono::high_resolution_clock::now().time_since_epoch()).count();",
      "mt19937_64 rng(rand_time);"
    ],
    "description": "Random_Number_Generator"
  },
  "Segment_tree": {
    "prefix": "_segment_tree",
    "body": [
      "template<typename T,typename F>",
      "struct SegmentTree{",
      "",
      "  int size;",
      "  vector<T> seg;",
      "  const F func;",
      "  const T UNIT;",
      "  ",
      "  SegmentTree(int N,F func , T UNIT): func(func) , UNIT(UNIT) {",
      "    size = 1;",
      "    while(size < N) size <<= 1;",
      "    seg.assign(2 * size, UNIT);",
      "  }",
      "",
      "  SegmentTree(const vector<T> &v,F func , T UNIT) : func(func) , UNIT(UNIT){",
      "    int N = (int)v.size();",
      "    size = 1;",
      "    while(size < N) size <<= 1;",
      "    seg.assign(2 * size , UNIT);",
      "    for(int i = 0; i < N; i++){",
      "      seg[i + size] = v[i];",
      "    }",
      "    build();",
      "  }",
      "",
      "  void set(int k, T x){",
      "    seg[k + size] = x;",
      "  }",
      "",
      "  void build(){",
      "    for(int k = size-1; k > 0; k--){",
      "      seg[k] = func(seg[2 * k] , seg[2 * k + 1] );",
      "    }",
      "  }",
      "  ",
      "  void update(int k, T x){",
      "    k += size; seg[k] = x;",
      "    while(k >>= 1){",
      "      seg[k] = func( seg[2 * k] , seg[2 * k + 1] );",
      "    }",
      "  }",
      "",
      "  void add(int k , T x){",
      "    k += size; seg[k] += x;",
      "    while(k >>= 1){",
      "      seg[k] = func(seg[2 * k] , seg[2 * k + 1] );",
      "    }",
      "  }",
      "  ",
      "  // query to [a, b) ",
      "  T query(int a, int b){",
      "    T L = UNIT, R = UNIT;",
      "    for(a+=size,b+=size; a<b; a>>=1,b>>=1){",
      "      if(a & 1) L = func(L,seg[a++]);",
      "      if(b & 1) R = func(seg[--b],R);",
      "    }",
      "    return func(L, R);",
      "  }",
      "",
      "  T& operator[](const int &k){",
      "    return seg[k + size];",
      "  }",
      "",
      "};"
    ],
    "description": "Segment_tree"
  },
  "lowest_common_ancestor": {
    "prefix": "_LCA",
    "body": [
      "UWG<int> g;",
      "",
      "struct HLD{",
      "  ",
      "  int idx;",
      "  vector<int> size, depth, in, out, nxt, par;",
      "  HLD(int N):idx(0),size(N,0),depth(N,0),in(N,-1),out(N,-1),nxt(N,0),par(N,0){",
      "    dfs_sz();",
      "    trc(size); trc(depth);",
      "    dfs_hld();",
      "    trc(in); trc(out); trc(nxt);",
      "  }",
      "  ",
      "  void dfs_sz(int cur=0,int p=-1,int d=0){",
      "    size[cur] = 1; depth[cur] = d; par[cur] = p;",
      "    for(auto &dst: g[cur]){",
      "      if(dst == p) continue;",
      "      dfs_sz(dst , cur , d + 1);",
      "      size[cur] += size[dst];",
      "      if(size[dst] > size[g[cur][0]]){",
      "        swap(dst , g[cur][0]);",
      "      }",
      "    }",
      "  }",
      "  void dfs_hld(int cur = 0,int p = -1){",
      "    in[cur] = idx++;",
      "    for(auto dst: g[cur]){",
      "      if(dst == p) continue;",
      "      nxt[dst] = ( (int)dst == g[cur][0] ? nxt[cur] : dst);",
      "      dfs_hld(dst);",
      "    }",
      "    out[cur] = idx;",
      "  }",
      "",
      "  int lca(int a,int b){",
      "    while(nxt[a] != nxt[b]){",
      "      if(depth[nxt[a]] < depth[nxt[b]]) swap(a,b);",
      "      a = par[nxt[a]];",
      "    }",
      "    return depth[a] < depth[b] ? a : b;",
      "  }",
      "};"
    ],
    "description": "lowest_common_ancestor"
  },
  "for a<=i<=b": {
    "prefix": "_for",
    "body": [
      "for ( int ${1:i} = ${2:1} ; $1 <= $3 ; $1++ ){",
      "\t$0",
      "}"
    ],
    "description": "for a<=i<=b"
  },
  "ModInt": {
    "prefix": "_mint",
    "body": [
      "template< int mod >",
      "struct ModInt {",
      "  int x;",
      "",
      "  ModInt() : x(0) {}",
      "",
      "  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}",
      "",
      "  ModInt &operator+=(const ModInt &p) {",
      "    if((x += p.x) >= mod) x -= mod;",
      "    return *this;",
      "  }",
      "",
      "  ModInt &operator-=(const ModInt &p) {",
      "    if((x += mod - p.x) >= mod) x -= mod;",
      "    return *this;",
      "  }",
      "",
      "  ModInt &operator*=(const ModInt &p) {",
      "    x = (int) (1LL * x * p.x % mod);",
      "    return *this;",
      "  }",
      "",
      "  ModInt &operator/=(const ModInt &p) {",
      "    *this *= p.inverse();",
      "    return *this;",
      "  }",
      "",
      "  ModInt operator-() const { return ModInt(-x); }",
      "",
      "  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }",
      "",
      "  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }",
      "",
      "  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }",
      "",
      "  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }",
      "",
      "  bool operator==(const ModInt &p) const { return x == p.x; }",
      "",
      "  bool operator!=(const ModInt &p) const { return x != p.x; }",
      "",
      "  ModInt inverse() const {",
      "    int a = x, b = mod, u = 1, v = 0, t;",
      "    while(b > 0) {",
      "      t = a / b;",
      "      swap(a -= t * b, b);",
      "      swap(u -= t * v, v);",
      "    }",
      "    return ModInt(u);",
      "  }",
      "",
      "  ModInt pow(int64_t n) const {",
      "    ModInt ret(1), mul(x);",
      "    while(n > 0) {",
      "      if(n & 1) ret *= mul;",
      "      mul *= mul;",
      "      n >>= 1;",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  friend ostream &operator<<(ostream &os, const ModInt &p) {",
      "    return os << p.x;",
      "  }",
      "",
      "  friend istream &operator>>(istream &is, ModInt &a) {",
      "    int64_t t;",
      "    is >> t;",
      "    a = ModInt< mod >(t);",
      "    return (is);",
      "  }",
      "",
      "  static constexpr int get_mod() { return mod; }",
      "};",
      "using mint = ModInt<MOD>;",
      "using vm = vector<mint>;"
    ],
    "description": "ModInt"
  },
  "Graph_Template": {
    "prefix": "_g",
    "body": [
      "template <typename T>",
      "struct edge {",
      "  int src, to;",
      "  T cost;",
      "",
      "  edge(int to, T cost) : src(-1), to(to), cost(cost) {}",
      "  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}",
      "",
      "  edge &operator=(const int &x) {",
      "    to = x;",
      "    return *this;",
      "  }",
      "",
      "  operator int() const { return to; }",
      "};",
      "template <typename T>",
      "using Edges = vector<edge<T>>;",
      "template <typename T>",
      "using WeightedGraph = vector<Edges<T>>;",
      "using UnweightedGraph = vector<vector<int>>;",
      "",
      "// Input of (Unweighted) Graph",
      "UnweightedGraph graph(int N, int M = -1, bool is_directed = false,",
      "                      bool is_1origin = true) {",
      "  UnweightedGraph g(N);",
      "  if (M == -1) M = N - 1;",
      "  for (int _ = 0; _ < M; _++) {",
      "    int x, y;",
      "    cin >> x >> y;",
      "    if (is_1origin) x--, y--;",
      "    g[x].pb(y);",
      "    if (!is_directed) g[y].pb(x);",
      "  }",
      "  return g;",
      "}",
      "",
      "// Input of Weighted Graph",
      "template <typename T>",
      "WeightedGraph<T> wgraph(int N, int M = -1, bool is_directed = false,",
      "                        bool is_1origin = true) {",
      "  WeightedGraph<T> g(N);",
      "  if (M == -1) M = N - 1;",
      "  for (int _ = 0; _ < M; _++) {",
      "    int x, y;",
      "    cin >> x >> y;",
      "    T c;",
      "    cin >> c;",
      "    if (is_1origin) x--, y--;",
      "    g[x].eb(x, y, c);",
      "    if (!is_directed) g[y].eb(y, x, c);",
      "  }",
      "  return g;",
      "}",
      "",
      "// Depth of Rooted Tree",
      "// unvisited nodes : d = -1",
      "vector<int> Depth(UnweightedGraph &g, int start = 0) {",
      "  vector<int> d(g.size(), -1);",
      "  auto dfs = [&](auto rec, int cur, int par = -1) -> void {",
      "    d[cur] = par == -1 ? 0 : d[par] + 1;",
      "    each(dst, g[cur]) {",
      "      if (dst == par) continue;",
      "      rec(rec, dst, cur);",
      "    }",
      "  };",
      "  dfs(dfs, start);",
      "  return d;",
      "}",
      "",
      "// Diameter of Tree",
      "pair<int, int> Diameter(UnweightedGraph &g, int start = 0) {",
      "  auto d = Depth(g, start);",
      "  int u = max_element(begin(d), end(d)) - begin(d);",
      "  d = Depth(g, u);",
      "  int v = max_element(begin(d), end(d)) - begin(d);",
      "  return make_pair(u, v);",
      "}",
      "",
      "template <typename G>",
      "vector<int> path(G &g, int u, int v) {",
      "  vi ret;",
      "  int end = 0;",
      "  auto dfs = [&](auto rec, int cur, int par = -1) -> void {",
      "    ret.pb(cur);",
      "    if (cur == v) {",
      "      end = 1;",
      "      return;",
      "    }",
      "    each(dst, g[cur]) {",
      "      if (dst == par) continue;",
      "      rec(rec, dst, cur);",
      "      if (end) return;",
      "    }",
      "    if (end) return;",
      "    ret.pop_back();",
      "  };",
      "  dfs(dfs, u);",
      "  return ret;",
      "}"
    ],
    "description": "Graph_Template"
  },
  "Lazy_Segment_Tree": {
    "prefix": "_LazySegmentTree",
    "body": [
      "// LazySegmentTree",
      "template <typename T,typename E,typename F,typename G,typename H>",
      "struct LST{",
      "  int n,height;",
      "  F f;",
      "  G g;",
      "  H h;",
      "  T ti;",
      "  E ei;",
      "  vector<T> dat;",
      "  vector<E> laz;",
      "  LST(int n, F f,G g,H h,T ti,E ei):",
      "    f(f),g(g),h(h),ti(ti),ei(ei){",
      "      init(n);",
      "  }",
      "  LST(const vector<T> &v, F f,G g,H h,T ti,E ei):",
      "    f(f),g(g),h(h),ti(ti),ei(ei){",
      "      init( (int)v.size() );",
      "      build(v);",
      "  }",
      "  ",
      "  void init(int n_){",
      "    n=1;height=0;",
      "    while(n<n_) n<<=1,height++;",
      "    dat.assign(2*n,ti);",
      "    laz.assign(2*n,ei);",
      "  }",
      "  void build(const vector<T> &v){",
      "    int n_=v.size();",
      "    init(n_);",
      "    for(int i=0;i<n_;i++) dat[n+i]=v[i];",
      "    for(int i=n-1;i;i--)",
      "      dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);",
      "  }",
      "  inline T reflect(int k){",
      "    return laz[k]==ei?dat[k]:g(dat[k],laz[k]);",
      "  }",
      "  inline void eval(int k){",
      "    if(laz[k]==ei) return;",
      "    laz[(k<<1)|0]=h(laz[(k<<1)|0],laz[k]);",
      "    laz[(k<<1)|1]=h(laz[(k<<1)|1],laz[k]);",
      "    dat[k]=reflect(k);",
      "    laz[k]=ei;",
      "  }",
      "  inline void thrust(int k){",
      "    for(int i=height;i;i--) eval(k>>i);",
      "  }",
      "  inline void recalc(int k){    ",
      "    while(k>>=1)",
      "      dat[k]=f(reflect((k<<1)|0),reflect((k<<1)|1));",
      "  }",
      "  void update(int a,int b,E x){",
      "    thrust(a+=n);",
      "    thrust(b+=n-1);",
      "    for(int l=a,r=b+1;l<r;l>>=1,r>>=1){",
      "      if(l&1) laz[l]=h(laz[l],x),l++;",
      "      if(r&1) --r,laz[r]=h(laz[r],x);",
      "    }",
      "    recalc(a);",
      "    recalc(b);",
      "  }",
      "  void set_val(int a,T x){",
      "    thrust(a+=n);",
      "    dat[a]=x;laz[a]=ei;",
      "    recalc(a);",
      "  }",
      "  T query(int a,int b){",
      "    thrust(a+=n);",
      "    thrust(b+=n-1);",
      "    T vl=ti,vr=ti;",
      "    for(int l=a,r=b+1;l<r;l>>=1,r>>=1) {",
      "      if(l&1) vl=f(vl,reflect(l++));",
      "      if(r&1) vr=f(reflect(--r),vr);",
      "    }",
      "    return f(vl,vr);",
      "  }",
      "};"
    ],
    "description": "Lazy_Segment_Tree"
  },
  "Heavy_Light_Decomposition_old": {
    "prefix": "_unused_1",
    "body": [
      "// HL分解",
      "// 木の内部の任意の2点間をO(log_V)個に分割するデータ構造。",
      "// これを用いることで木に対してセグ木やbitなどのデータ構造を用いることが出来る。",
      "// 以下、内部のデータの説明。(頂点0を根とした。)",
      "// size[i] ... iの部分木の要素数 depth[i] ... iの深さ(depth[0] = 0)",
      "// nxt[i] ... vから根に向かって伸びるheavy pathの終着点(nxt[0] = 0)",
      "// in[i],out[i] ... オイラーツアーした時の順番。",
      "// [ in[i] , out[i] )で部分木へのクエリとなる。",
      "// [ in[nxt[i]] , in[v] ]でheavy pathへのクエリとなる。",
      "// par[i] ... iの親ノード。 (par[0] = 0)",
      "// verify",
      "// ABC133F https://atcoder.jp/contests/abc133/submissions/6357522",
      "// AOJ-GRL-5C http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3742268#1",
      "// AOJ-GRL-5D https://onlinejudge.u-aizu.ac.jp/status/users/NyaanNyaan/submissions/1/GRL_5_D/judge/3742298/C++14",
      "// AOJ-GRL-5E https://onlinejudge.u-aizu.ac.jp/status/users/NyaanNyaan/submissions/1/GRL_5_E/judge/3742347/C++14",
      "",
      "template<typename G = vector<vector<int> > > struct HeavyLightDecomposition{",
      "  G& g;",
      "  int idx;",
      "  vector<int> size, depth, in, out, nxt, par;",
      "  HeavyLightDecomposition(G &g,int root = 0) : ",
      "    g(g),idx(0),size(g.size(),0),depth(g.size(),0),in(g.size(),-1),out(g.size(),-1),nxt(g.size(),0),par(g.size(),root){",
      "    dfs_sz(root);",
      "    dfs_hld(root);",
      "  }",
      "  ",
      "  void build(int root){",
      "    dfs_sz(root);",
      "    dfs_hld(root);",
      "  }",
      "",
      "  // 構築",
      "  void dfs_sz(int cur){",
      "    size[cur] = 1;",
      "    for(auto &dst: g[cur]){",
      "      if(dst == par[cur]) {",
      "        if( g[cur].size() >= 2 && int(dst) == int(g[cur][0]) ) ",
      "          swap(g[cur][0] , g[cur][1]);",
      "        else continue;",
      "      }",
      "      depth[dst] = depth[cur] + 1;",
      "      par[dst] = cur;",
      "      dfs_sz(dst);",
      "      size[cur] += size[dst];",
      "      if(size[dst] > size[g[cur][0]]){",
      "        swap(dst , g[cur][0]);",
      "      }",
      "    }",
      "  }",
      "  void dfs_hld(int cur){",
      "    in[cur] = idx++;",
      "    for(auto dst: g[cur]){",
      "      if(dst == par[cur]) continue;",
      "      nxt[dst] = ( int(dst) == int(g[cur][0]) ? nxt[cur] : int(dst) );",
      "      dfs_hld(dst);",
      "    }",
      "    out[cur] = idx;",
      "  }",
      "",
      "  // 辺クエリ",
      "  // aからbへの辺(aが根の側,bが葉の側)の持つ値をstのdata[b]に代入しているとする。",
      "  // (すなわち、辺のデータを葉の方の頂点に移し替える。)",
      "  // (注: 例外処理のためdata[0] = fの単位元とする。)",
      "  // この時、st.query(u,v + 1)はpar[u]からvまでの辺へのクエリとなる。",
      "  // (注: st.query()は引数に半開区間をため第二引数のvに1を足している。)",
      "  // これをもとに[u , v]の辺へのクエリを実装する。",
      "",
      "  template<typename F>",
      "  void edge_query(int u,int v,const F& f){",
      "    while(1){",
      "      if(in[u] > in[v]) swap(u,v);",
      "      trc(u,v);",
      "      if(nxt[u] != nxt[v]){",
      "        f(in[nxt[v]] , in[v] + 1);",
      "        v = par[ nxt[v] ];",
      "      }",
      "      else{",
      "        trc(u , v,in[u] , in[v]);",
      "        if(u != v) f(in[u] + 1, in[v] + 1);",
      "        break;",
      "      }",
      "    }",
      "  }",
      "",
      "  // 頂点クエリ (verifyしていない)",
      "  // 辺クエリと同様の議論をする。",
      "  // たぶん最後の同じheavy pathに載ったところを、",
      "  // in[u]+1からin[u]にかえれば正しく動くと思う。",
      "  template<typename F>",
      "  void node_query(int u,int v,const F& f){",
      "    while(1){",
      "      if(in[u] > in[v]) swap(u,v);",
      "      trc(u,v);",
      "      if(nxt[u] != nxt[v]){",
      "        f(in[nxt[v]] , in[v] + 1);",
      "        v = par[ nxt[v] ];",
      "      }",
      "      else{",
      "        trc(u , v,in[u] , in[v]);",
      "        f(in[u], in[v] + 1);",
      "        break;",
      "      }",
      "    }",
      "  }",
      "",
      "  // 部分木クエリ",
      "  template<typename F>",
      "  void sub_edge_query(int u,const F& f){",
      "    f(in[u] + 1, out[u]);",
      "  }",
      "  template<typename F>",
      "  void sub_node_query(int u,const F& f){",
      "    f(in[u], out[u]);",
      "  }",
      "",
      "  // 最小共通祖先 ",
      "  int lca(int a,int b){",
      "    while(nxt[a] != nxt[b]){",
      "      if( in[a] < in[b] ) swap(a,b);",
      "      a = par[nxt[a]];",
      "    }",
      "    return depth[a] < depth[b] ? a : b;",
      "  }",
      "};"
    ],
    "description": "Heavy_Light_Decomposition"
  },
  "Binary_Indexed_Tree": {
    "prefix": "_bitree",
    "body": [
      "// BIT",
      "",
      "template< typename T >",
      "struct BIT {",
      "  int N; int max_2beki;",
      "",
      "  vector< T > data;",
      "  // 初期化 1-indexedでデータを管理する 0で初期化",
      "  BIT(int size){",
      "      N = ++size;",
      "      data.assign(N, 0);",
      "      max_2beki = 1;",
      "      while(max_2beki * 2 <= N) max_2beki *= 2;",
      "  }",
      "",
      "  // [0,k](閉区間)の総和 閉区間に注意！",
      "  T sum(int k) {",
      "    if(k < 0) return 0; // k<0のとき0を返す",
      "    T ret = 0;",
      "    for(++k; k > 0; k -= k & -k) ret += data[k];",
      "    return (ret);",
      "  }",
      "",
      "  // [l,r](閉区間)の総和",
      "  inline T sum(int l,int r){",
      "    return sum(r) - sum(l-1);",
      "  }",
      "",
      "  // 一点取得 更新はできないことに注意",
      "  inline T operator[](int k){",
      "    return sum(k) - sum(k-1);",
      "  }",
      "",
      "  // data[k] += x;",
      "  void add(int k, T x) {",
      "    for(++k; k < N; k += k & -k) data[k] += x;",
      "  }",
      "",
      "  // imos法 [l,r]にxを加算",
      "  void imos(int l,int r,T x){",
      "    add(l , x); add(r + 1 , -x);",
      "  }",
      "",
      "  // lower_bound sum(i)がval以上となる最小のi",
      "  int lower_bound(T w){",
      "    if(w <= 0) return 0;",
      "    int x = 0;",
      "    for(int k = max_2beki; k > 0; k /= 2){",
      "      if(x+k <= N - 1 && data[x + k] < w){",
      "        w -= data[x + k];",
      "        x += k;",
      "      }",
      "    }",
      "    return x;",
      "  }",
      "",
      "  // upper_bound sum(i)がvalより大きくなる最小のi",
      "  int upper_bound(T w){",
      "    if(w < 0) return 0;",
      "    int x = 0;",
      "    for(int k = max_2beki; k > 0; k /= 2){",
      "      if(x+k <= N - 1 && data[x + k] <= w){",
      "        w -= data[x + k];",
      "        x += k;",
      "      }",
      "    }",
      "    return x;",
      "  }",
      "",
      "};"
    ],
    "description": "Binary_Indexed_Tree"
  },
  "Rolling_Hash": {
    "prefix": "_RollingHash",
    "body": [
      "",
      "// 使い方",
      "// 文字列のハッシュ列 Roriha s_rori(S);",
      "// 配列のハッシュ列 RollingHash<vector<int>> vrori(v);",
      "template<typename string_t> struct RollingHash{",
      "  using ull = unsigned long long;",
      "  using Pu = pair<ull , ull>;",
      "  string_t& data;",
      "  vector<Pu> hashed , power;",
      "  int size_;",
      "  static Pu basis;",
      "  ",
      "  static constexpr ull rmod = (1ull << 61) - 1;",
      "  ",
      "  static constexpr ull mul(const ull a,const ull b){",
      "    ull l1 = (uint32_t)a, h1 = a>>32, l2 = (uint32_t)b, h2 = b>>32;",
      "    ull l = l1*l2, m = l1*h2 + l2*h1, h = h1*h2;",
      "    ull ret = (l & rmod) + (l>>61) + (h << 3) + (m >> 29) + (m << 35 >> 3);",
      "    if(ret > rmod) ret = (ret & rmod) + (ret>>61);",
      "    if(ret >= rmod) ret -= rmod;",
      "    return ret;",
      "  }",
      "  static constexpr ull mul_plus(const ull a,const ull b,const ull c){",
      "    ull l1 = (uint32_t)a, h1 = a>>32, l2 = (uint32_t)b, h2 = b>>32;",
      "    ull l = l1*l2, m = l1*h2 + l2*h1, h = h1*h2;",
      "    ull ret = (l & rmod) + (l >> 61) + (h << 3) + (m >> 29) + (m << 35 >> 3) + c;",
      "    if(ret > rmod) ret = (ret & rmod) + (ret>>61);",
      "    if(ret >= rmod) ret -= rmod;",
      "    return ret;",
      "  }",
      "  static constexpr ull modpow(ull a,ull b){",
      "    a %= rmod;",
      "    ull r = 1;",
      "    while(b) {",
      "      if(b & 1) r = mul(r , a);",
      "      a = mul(a , a);",
      "      b >>= 1;",
      "    }",
      "    return r;",
      "  }",
      "  static constexpr bool isPrimitive(ull x, vector<ull> &ds) {",
      "    for(ll d : ds)",
      "      if(d != rmod - 1) {",
      "        if(modpow( x, (rmod - 1) / d ) == 1) return false;",
      "      }",
      "    return true;",
      "  }",
      "  static constexpr Pu get_basis(){",
      "    vector<ull> ds = {2,3,5,7,11,13,31,41,61,151,331,1321};",
      "    auto rand_time = chrono::duration_cast<chrono::nanoseconds>(chrono::high_resolution_clock::now().time_since_epoch()).count();",
      "    mt19937_64 rng(rand_time);",
      "    ull a = -1 , b = -1;",
      "    do{ a = rng() % rmod; }while(isPrimitive(a , ds) == false);",
      "    do{ b = rng() % rmod; }while(a == b || isPrimitive(b , ds) == false);",
      "    return Pu(a , b);",
      "  }",
      "",
      "  // Rolling Hashの構築　O( |S| )",
      "  RollingHash(string_t &S) : data(S) , size_((int)S.size()){",
      "    // hashed[i] 部分列[0 , i)のハッシュを記録 hashed[0] = (0,0)",
      "    // power[i] basisのi乗を記録",
      "    hashed.resize(size_ + 1);",
      "    power.resize(size_ + 1);",
      "    power[0] = Pu(1 , 1); hashed[0] = Pu(0 , 0);",
      "    for(int i = 1 ; i <= size_ ; i++ ){",
      "      power[i].fi = mul( power[i - 1].fi , basis.fi);",
      "      power[i].se = mul( power[i - 1].se , basis.se);",
      "      hashed[i].fi = mul_plus( hashed[i - 1].fi , basis.fi , S[i - 1]);",
      "      hashed[i].se = mul_plus( hashed[i - 1].se , basis.se , S[i - 1]);",
      "    }",
      "  }",
      "",
      "  // 部分文字列[ l , r )のハッシュを取得 O(1)",
      "  Pu get(const int l , const int r){",
      "    Pu ret;",
      "    ret.fi = rmod - mul_plus( hashed[l].fi , power[r-l].fi , rmod - hashed[r].fi );",
      "    ret.se = rmod - mul_plus( hashed[l].se , power[r-l].se , rmod - hashed[r].se );",
      "    return ret;",
      "  }",
      "",
      "  // 別の文字列のハッシュを取得　O( |T| )",
      "  Pu get_hash(string_t &T){",
      "    Pu ret = Pu(0 , 0);",
      "    for(int i = 0 ; i < (int)T.size() ; i++){",
      "      ret.fi = mul_plus(ret.fi , basis.fi , T[i]);",
      "      ret.se = mul_plus(ret.se , basis.se , T[i]);",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  // 別の文字列と一致判定 O ( |S| + |T| )",
      "  // 存在するときは最初の文字を、存在しないときは-1を返す",
      "  int find(string_t &T){",
      "    auto t_hash = get_hash(T);",
      "    int t_size = (int)(T.size());",
      "    // |S| < |T|の時はfor文の中に入らないことに留意する",
      "    for(int i = 0 ; i <= size_ - t_size ; i++){",
      "      if(t_hash == get( i , i + t_size ) ) return i;",
      "    }",
      "    return -1;",
      "  }",
      "",
      "  // 別の文字列と一致判定 O ( |S| + |T| )",
      "  // 一致する文字列のindexをすべて返す",
      "  vector<int> find_all(string_t &T){",
      "    auto t_hash = get_hash(T);",
      "    int t_size = (int)(T.size());",
      "    vector<int> ret;",
      "    // |S| < |T|の時はfor文の中に入らないことに留意する",
      "    for(int i = 0 ; i <= size_ - t_size ; i++){",
      "      if(t_hash == get( i , i + t_size ) ) ret.push_back(i);",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  // Longest Common Prefix(最長共通接頭辞) O( log |S| )",
      "  // Sの[al , ar)とTの[bl , br)の最長共通接頭辞の長さを求める",
      "  // 引数 (文字列Tのハッシュ列 , 文字列Sの開始地点a , 文字列Tの開始地点b)",
      "  // 返り値　最長共通接頭辞の長さ",
      "  int LongestCommonPrefix(RollingHash<string_t> &t , int al , int bl , int ar = -1 , int br = -1){",
      "    if(ar == -1) ar = size_;",
      "    if(br == -1) br = t.size_;",
      "    int ok = 0 , ng = min(ar - al , br - bl)  + 1;",
      "    while(ok + 1 < ng){",
      "      int med = (ok + ng) / 2;",
      "      if( get(al , med + al) == t.get(bl , med + bl) ) ok = med;",
      "      else ng = med;",
      "    }",
      "    return ok;",
      "  }",
      "",
      "  // 文字列の大小比較 O( log |S + T| )　",
      "  // Sの[al , ar)とTの[bl , br)の最長共通接頭辞の長さを求める",
      "  // 返り値 1 Sのほうが大きい 0 同じ -1 Tのほうが大きい",
      "  int strcmp(RollingHash<string_t> &t , int al , int bl , int ar = -1 , int br = -1){",
      "    if(ar == -1) ar = size_;",
      "    if(br == -1) br = t.size_;",
      "    int n = LongestCommonPrefix(t , al , bl , ar , br);",
      "    if(al + n == ar)",
      "      return (bl + n == br) ? 0 : 1;",
      "    else if(bl + n == br)",
      "      return -1;",
      "    else return ( data[al + n] < t.data[bl + n] ) ? 1 : -1; ",
      "  }",
      "  ",
      "  // 文字列内の最長一致部分文字列を検索 O ( |S| (log|S|)^2 )",
      "  int LongestCommonSubString(){",
      "    auto func = [&](int len) -> bool {",
      "      map < Pu , int > m;",
      "      for(int i = 0 ; i <= size_ - len ; i++){",
      "        if( (m[get(i , i + len)] += 1) != 1) return true;",
      "      }",
      "      return false; ",
      "    };",
      "    int ok = 0 , ng = size_ ;",
      "    while(ok + 1 < ng){",
      "      int med = (ok + ng) / 2;",
      "      if(func(med)) ok = med;",
      "      else ng = med;",
      "    }",
      "    return ok;",
      "  }",
      "",
      "};",
      "// ロリハのハッシュの初期化",
      "template<typename T> pair<unsigned long long,unsigned long long> RollingHash<T>::basis = RollingHash<T>::get_basis();",
      "using Roriha = RollingHash<string>;"
    ],
    "description": "Rolling_Hash"
  },
  "Binomial_Coefficients": {
    "prefix": "_binomial",
    "body": [
      "vector<ll> fac,finv,inv;",
      "void cominit(int MAX) {",
      "  MAX++;",
      "  fac.resize(MAX , 0);",
      "  finv.resize(MAX , 0);",
      "  inv.resize(MAX , 0);",
      "  fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1;",
      "  for (int i = 2; i < MAX; i++){",
      "    fac[i] = fac[i - 1] * i % MOD;",
      "    inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;",
      "    finv[i] = finv[i - 1] * inv[i] % MOD;",
      "  }",
      "}",
      "// nCk combination ",
      "inline long long COM(int n,int k){",
      "  if(n < k || k < 0 || n < 0) return 0;",
      "  else return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;",
      "}",
      "// nPk permutation",
      "inline long long PER(int n,int k){",
      "  if (n < k || k < 0 || n < 0) return 0;",
      "  else return (fac[n] * finv[n - k]) % MOD;",
      "}",
      "// nHk homogeneous polynomial",
      "inline long long HGP(int n,int k){",
      "  if(n == 0 && k == 0) return 1; // depending on problem?",
      "  else if(n < 1 || k < 0) return 0;",
      "  else return fac[n + k - 1] * (finv[k] * finv[n - 1] % MOD) % MOD;",
      "}"
    ],
    "description": "Binary_Combination"
  },
  "Slide_Min_Max": {
    "prefix": "_slide",
    "body": [
      "// スライド最大値/最小値 連続するK個の演算の和",
      "// dat[i] ... 区間[ max(0 , i - K)  , i) の最大値",
      "template<typename T, typename A, typename F, T UNIT>",
      "struct Slide{",
      "  vector<T> dat;",
      "  Slide(A &v , int N , int K , F f){",
      "    rep(i,N) trc(i,v[i]);",
      "    dat.resize(N + 1);",
      "    dat[0] = UNIT;",
      "    deque<int> q;",
      "    for(int i = 0; i < K - 1; i++){",
      "      while(!q.empty() && ( f(v[i] , v[q.back()]) == v[i] ) )",
      "        q.pop_back();",
      "      q.push_back(i);",
      "      dat[i + 1] = v[q.front()];",
      "    }",
      "    for(int i = K; i < N + 1; i++){",
      "      T cur = v[i - 1];",
      "      while(!q.empty() && ( f(cur , v[q.back()]) == cur) ) ",
      "        q.pop_back();",
      "      q.push_back(i - 1);",
      "      dat[i] = v[q.front()];",
      "      if(q.front() == i - K) q.pop_front();",
      "    }",
      "  }",
      "};"
    ],
    "description": "Slide_Min_Max"
  },
  "grid": {
    "prefix": "_grid",
    "body": [
      "//Grid Library",
      "#ifdef NyaanDebug",
      "  #define gtrc() g_trace()",
      "#else ",
      "  #define gtrc() 1",
      "#endif",
      "int H,W; vector<string> g;",
      "const int dx[]={1,0,-1,0}; const int dy[]={0,1,0,-1};const int dn = 4;",
      "//const int dx[]={1,1,1,0,-1,-1,-1,0}; const int dy[]={1,0,-1,-1,-1,0,1,1};const int dn = 8;",
      "//using PP = pair<pair<int,int>,pair<int,int>>;",
      "inline bool ok(int x,int y){return 0<=x && x<H && 0<=y && y<W ;}",
      "void g_trace(){ rep(i,H) cerr << g[i] << endl; }",
      "void grid(){ cin>>H>>W; g.resize(H); rep(i,H) cin>>g[i]; }"
    ],
    "description": "grid"
  },
  "bellman_ford_algorithm": {
    "prefix": "_bellman_ford",
    "body": [
      "",
      "// bellman-ford法",
      "// goalが存在しないとき-> 負閉路が存在するときは空列を返す",
      "// goalが存在するとき  -> startとgoalの間に負閉路が存在する時に負閉路を返す",
      "template<typename T>",
      "vector<T> bellman_ford(int N, Edges<T>& es , int start = 0 , int goal = -1){",
      "  T INF = numeric_limits< T >::max() / 2;",
      "  vector<T> d(N , INF);",
      "  d[start] = 0;",
      "  for(int i = 0 ; i < N ; i++){",
      "    bool update = false;",
      "    for(auto &e : es){",
      "      if(d[e.src] == INF) continue;",
      "      if(d[e.to] > d[e.src] + e.cost){",
      "        update = true , d[e.to] = d[e.src] + e.cost;",
      "      }",
      "    }",
      "    if(!update) return d;",
      "  }",
      "",
      "  if(goal == -1) return vector<T>();",
      "  vector<bool> negative(N , false);",
      "  for(int i = 0 ; i < N ; i++){",
      "    for(auto &e : es){",
      "      if(d[e.src] == INF) continue;",
      "      if(d[e.to] > d[e.src] + e.cost)",
      "        negative[e.to] = true , d[e.to] = d[e.src] + e.cost;",
      "      if(negative[e.src] == true)",
      "        negative[e.to] = true;",
      "    }",
      "  }",
      "",
      "  if(negative[goal] == true) return vector<T>();",
      "  else return d;  ",
      "}"
    ],
    "description": "bellman_ford_algorithm"
  },
  "2D_BIT": {
    "prefix": "_BIT2D",
    "body": [
      "",
      "template<typename T>",
      "struct BIT2D{",
      "  int H,W;",
      "  vector<vector<T>> bit;",
      "  BIT2D(int H,int W):H(H),W(W){",
      "    bit.resize(H + 1 , vector<T>(W + 1 , 0));",
      "  }",
      "  // 関数の入力のindexは0-originを想定",
      "",
      "  // (x,y)にwを足す",
      "  // 範囲外の時は足さない",
      "  void add(int x, int y, T w){",
      "    if(x < 0 || x >= H || y < 0 || y >= W) return;",
      "    for(int a = (++y , ++x); a <= H; a += a & -a){",
      "      for(int b = y ; b <= W; b += b & -b){",
      "        bit[a][b] += w;",
      "      }",
      "    }",
      "  }",
      "",
      "  // imos法で[(x1,y1) , (x2,y2)]にwを足す",
      "  void imos(int x1, int y1, int x2, int y2, T w){",
      "    add(x1 , y1 , w);",
      "    add(x1 , y2 + 1 , -w);",
      "    add(x2 + 1 , y1 , -w);",
      "    add(x2 + 1 , y2 + 1 , w);",
      "  }",
      "",
      "  //  [(0,0) , (x,y)]の和　閉区間に注意！",
      "  // x,y<0の時は0 x>=H y>=Wのときはx=H-1,y=W-1とみなす",
      "  // ( imos法の時は (x,y)の値を返す )",
      "  T sum(int x, int y){",
      "    if(x < 0 || y < 0) return 0;",
      "    if(x >= H) x = H - 1;",
      "    if(y >= W) y = W - 1;",
      "    T ret = 0;",
      "    for(int a = (++y , ++x) ; a > 0; a -= a & -a){",
      "      for(int b = y; b > 0; b -= b & -b){",
      "        ret += bit[a][b];",
      "      }",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  // [(x1,y1) , (x2,y2)] の和",
      "  // x1 > x2, y1 > y2の時はswap",
      "  T sum(int x1,int y1, int x2, int y2){",
      "    if(x1 > x2 || y1 > y2) return T(0);",
      "    return sum(x2,y2)-sum(x2,y1-1)-sum(x1-1,y2)+sum(x1-1,y1-1);",
      "  }",
      "};"
    ],
    "description": "2D_BIT"
  },
  "warshall_floyd_algorithm": {
    "prefix": "_warshall_floyd",
    "body": [
      "// ワーシャルフロイド法",
      "template<typename T>",
      "void warshall_floyd(T& d){",
      "  int N = sz(d[0]);",
      "  for(int i = 0 ; i < N ; i++)",
      "    d[i][i] = 0;",
      "  for(int k = 0 ; k < N ; k++)",
      "    for(int i = 0 ; i < N ; i++)",
      "      for(int j = 0 ; j < N ; j++)",
      "        d[i][j] = min(d[i][j] , d[i][k] + d[k][j]);",
      "}"
    ],
    "description": "warshall_floyd_algorithm"
  },
  "NTT_and_ArbitaryPrimitiveNTT": {
    "prefix": "_ntt",
    "body": [
      "",
      "template< int mod, int primitiveroot >",
      "struct NumberTheoreticTransform {",
      "  vector< vector< int > > rts, rrts;",
      "  void ensure_base(int N) {",
      "    if((int)rts.size() >= N) return;",
      "    rts.resize(N), rrts.resize(N);",
      "    for(int i = 1; i < N; i <<= 1) {",
      "      if(rts[i].size()) continue;",
      "      int w = mod_pow(primitiveroot, (mod - 1) / (i * 2));",
      "      int rw = inverse(w);",
      "      rts[i].resize(i), rrts[i].resize(i);",
      "      rts[i][0] = 1, rrts[i][0] = 1;",
      "      for(int k = 1; k < i; k++) {",
      "        rts[i][k] = mul(rts[i][k - 1], w);",
      "        rrts[i][k] = mul(rrts[i][k - 1], rw);",
      "      }",
      "    }",
      "  }",
      "",
      "  inline int mod_pow(int x, int n) {",
      "    int ret = 1;",
      "    while(n > 0) {",
      "      if(n & 1) ret = mul(ret, x);",
      "      x = mul(x, x);",
      "      n >>= 1;",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  inline int inverse(int x) {",
      "    return mod_pow(x, mod - 2);",
      "  }",
      "",
      "  inline int add(int x, int y) {",
      "    x += y;",
      "    if(x >= mod) x -= mod;",
      "    return x;",
      "  }",
      "",
      "  inline int mul(int a, int b) {",
      "    return int(1LL * a * b % mod);",
      "  }",
      "",
      "  void DiscreteFourierTransform(vector< int > &F, bool rev) {",
      "    const int N = (int) F.size();",
      "    ensure_base(N);",
      "    for(int i = 0, j = 1; j + 1 < N; j++) {",
      "      for(int k = N >> 1; k > (i ^= k); k >>= 1);",
      "      if(i > j) swap(F[i], F[j]);",
      "    }",
      "    for(int i = 1; i < N; i <<= 1) {",
      "      for(int j = 0; j < N; j += i * 2) {",
      "        for(int k = 0; k < i; k++) {",
      "          int s = F[j + k], t = mul(F[j + k + i], rev ? rrts[i][k] : rts[i][k]);",
      "          F[j + k] = add(s, t), F[j + k + i] = add(s, mod - t);",
      "        }",
      "      }",
      "    }",
      "    if(rev) {",
      "      int temp = inverse(N);",
      "      for(int i = 0; i < N; i++) F[i] = mul(F[i], temp);",
      "    }",
      "  }",
      "",
      "  vector< int > Multiply(const vector< int > &A, const vector< int > &B) {",
      "    int sz = 1;",
      "    while(sz < int(A.size()) + int(B.size()) - 1) sz <<= 1;",
      "    vector< int > F(sz), G(sz);",
      "    for(int i = 0; i < (int)A.size(); i++) F[i] = A[i];",
      "    for(int i = 0; i < (int)B.size(); i++) G[i] = B[i];",
      "    DiscreteFourierTransform(F, false);",
      "    DiscreteFourierTransform(G, false);",
      "    for(int i = 0; i < sz; i++) F[i] = mul(F[i], G[i]);",
      "    DiscreteFourierTransform(F, true);",
      "    F.resize(A.size() + B.size() - 1);",
      "    return F;",
      "  }",
      "};",
      "NumberTheoreticTransform< 1012924417, 5 > ntt_conv;",
      "",
      "",
      "// 任意長NTT",
      "// b[i] = Σ a[j] r^(ij) (mod p) (0 <= i,j <= p-2)を計算する",
      "template<typename T>",
      "struct ArbitaryLengthNTT{",
      "  T prime , size_; // 要素数 n = p - 1",
      "  vector<T> pr;",
      "  ArbitaryLengthNTT(T pp ) : prime(pp){",
      "    // rのべき乗",
      "    T p_primitive = primitive(prime);",
      "    //trc(p_primitive);",
      "    pr.resize(prime); pr[0] = 1; for(int i = 1; i < prime; i++) pr[i] = pr[i - 1] * p_primitive % prime;",
      "    //trc();trc(p_primitive); trc(pr);",
      "  }",
      "",
      "  vector<T> mul(vector<T> &a){",
      "    size_ = T(a.size());",
      "    //assert(size_ + 1 == prime);",
      "    if(size_ == 1) return vector<T>({a[0]});",
      "    vector<T> ret;",
      "    CooleyTukey(a , ret);",
      "    return ret;",
      "  }",
      "",
      "  void CooleyTukey(vector<T> &f , vector<T> &ret){",
      "    T N = f.size(); ",
      "    //assert(size_ % N == 0);",
      "    T P = iscomposite(N);",
      "    //trc(\"CooleyTukey\" , N , P);",
      "    if(P == 0){",
      "      Rader(f , ret); return;",
      "    }",
      "    T Q = N / P;",
      "    vector<T> f1(N);",
      "    {",
      "      vector<T> f2(Q) , f3(Q);",
      "      for(int p = 0; p < P; p++){",
      "        for(int q = 0; q < Q; q++) f2[q] = f[q * P + p];",
      "        CooleyTukey(f2 , f3);",
      "        for(int r = 0; r < Q; r++){",
      "          f1[p * Q + r] = pr[size_ / N * r * p] * f3[r] % prime;",
      "        }",
      "      }",
      "    }",
      "    ret.resize(N);",
      "    {",
      "      vector<T> f(P) , fret(P);",
      "      for(int r = 0; r < Q; r++){",
      "        for(int p = 0; p < P; p++) f[p] = f1[p * Q + r];",
      "        Rader(f , fret);",
      "        for(int s = 0; s < P; s++) ret[s * Q + r] = fret[s];",
      "      }",
      "    }",
      "    ",
      "  }",
      "",
      "  void Rader(vector<T> &f , vector<T> &ret){",
      "    T P = f.size();",
      "    //assert(size_ % P == 0);",
      "    //trc(\"Rader\" , P);",
      "    T g = primitive(P);",
      "    T ginv = modpow(g , P - 2 , P);",
      "    //trc(f , g , ginv);",
      "    vector<T> f2(P - 1) , f3(P - 1);",
      "    for(T x = 0 , cur = 1 , curinv = 1; x < P - 1; x++){",
      "      f2[x] = f[ cur ];",
      "      f3[x] = pr[size_ / P * curinv];",
      "      cur = cur * g % P;",
      "      curinv = curinv * ginv % P;",
      "    }",
      "    auto C = ntt_conv.Multiply(f2 , f3);",
      "    //trc(f2); trc(f3); trc(C);",
      "    ret.resize(P);",
      "    fill(ret.begin() , ret.end() , 0);",
      "    for(int i = 0; i < P; i++) ret[0] += f[i];",
      "    for(int i = 1; i < P; i++) ret[i] += f[0];",
      "    for(T y = 0 , cur = 1; y < T(C.size()); y++){",
      "      ret[cur] += C[y];",
      "      cur = cur * ginv % P;",
      "    }",
      "    for(int i = 0; i < P; i++) ret[i] %= prime;",
      "    //trc(ret);",
      "  }",
      "",
      "",
      "  T gcd(T a,T b){",
      "    if(a > b) swap(a,b);",
      "    while(a){ T c = a; a = b % a; b = c; } ",
      "    return b; ",
      "  }",
      "   T modpow(T a,T n, T mod){ ",
      "    T ret = 1;",
      "    while(n){",
      "      if(n & 1) ret = ret * a % mod;",
      "      n >>= 1;",
      "      a = a * a % mod;",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  T iscomposite(T a){ ",
      "    if(a <= 1) return 1;",
      "    for(T i = 2; i*i <= a; i++) { if( a % i == 0) return i; } ",
      "    return 0; ",
      "  }",
      "  T isprimitive(T a , T p){",
      "    if(a < 2) return false;",
      "    const T q = p - 1;",
      "    for(T i = 2; i * i <= q; i++){",
      "      if( q % i ) continue;",
      "      if(modpow(a , i , p) == 1) return false;",
      "      if(i * i != q && modpow(a , q/i , p) == 1) return false;",
      "    }",
      "    return true;",
      "  }",
      "  T primitive(T p){",
      "    if(p == 2) return 1;",
      "    T a = 2;",
      "    while(isprimitive(a , p) == false) a++;",
      "    return a;",
      "  }",
      " ",
      "};",
      "/**",
      "void test(){",
      "  clock_t start = clock();",
      "  int N = 97;",
      "  vector<int> x(N - 1);",
      "  rep(i , N - 1) x[i] = rand() % N;",
      "  ArbitaryLengthNTT<int> ntt(N);",
      "  vector<int> ans;",
      "  cout << (ans = ntt.mul(x)) << endl;",
      "  cerr << clock() - start << \"ms\" << endl;",
      "  ",
      "  int r = ntt.primitive(N);",
      "  vector<int> y(N - 1 , 0);",
      "  for(int k = 0; k < N - 1; k++)",
      "    for(int n = 0; n < N - 1; n++){",
      "      y[k] += x[n] * ntt.modpow(r , n * k , N);",
      "      y[k] %= N;",
      "    }",
      "  //out(y);",
      "  assert(ans == y);",
      "}",
      "//*/"
    ],
    "description": "NTT_and_ArbitaryPrimitiveNTT"
  },
  "coordinate_compression": {
    "prefix": "_compress",
    "body": [
      "template<class T>",
      "struct compress{",
      "  vector<T> xs;",
      "  compress(const vector<T>& v){",
      "    xs.reserve(v.size());",
      "    for(T x : v) xs.push_back(x);",
      "    sort(xs.begin(),xs.end());",
      "    xs.erase(unique(xs.begin(),xs.end()) , xs.end());",
      "  }",
      "",
      "  int get(const T& x){",
      "    return lower_bound(xs.begin(),xs.end(),x) - xs.begin();",
      "  }",
      "  int size(){",
      "    return xs.size();",
      "  }",
      "  T& operator[](int i){",
      "    return xs[i];",
      "  }",
      "};"
    ],
    "description": "coordinate_compression"
  },
  "solve_function": {
    "prefix": "_sol",
    "body": [
      "void solve(){",
      "$0",
      "}"
    ],
    "description": "solve_function"
  },
  "fast_rand": {
    "prefix": "_fastrand",
    "body": [
      "unsigned int rng(){static unsigned int x=123456789,y=362436069,z=521288629,w=88675123;unsigned int t;t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );}",
      "inline double rand_d(){return double(rand()) / UINT32_MAX; }",
      ""
    ],
    "description": "fast_rand"
  },
  "dijkstra's_algorithm": {
    "prefix": "_dijkstra",
    "body": [
      "",
      "// unreachable -> -1 ",
      "template<typename T>",
      "vector<T> dijkstra(WeightedGraph<T> &g, int start = 0){ ",
      "  using P = pair<T , int>;",
      "  int N = (int)g.size();",
      "  T INF = numeric_limits<T>::max() / 2;",
      "  vector<T> d(N , INF);",
      "  priority_queue<P , vector<P> , greater<P> > Q;",
      "  d[start] = 0;",
      "  Q.emplace(0 , start);",
      "  while(!Q.empty()){",
      "    P p = Q.top(); Q.pop();",
      "    int cur = p.second;",
      "    if(d[cur] < p.first) continue;",
      "    for(auto dst : g[cur]){",
      "      if( d[cur] + dst.cost < d[dst]){",
      "        d[dst] = d[cur] + dst.cost;",
      "        Q.emplace(d[dst] , dst);",
      "      }",
      "    }",
      "  }",
      "  return d;",
      "}"
    ],
    "description": "dijkstra's_algorithm"
  },
  "Topological_Sort": {
    "prefix": "_topologicalsort",
    "body": [
      "// トポロジカルソート DAGでない場合は空配列を返す",
      "template<typename T>",
      "vector<int> TopologicalSort(T &g){",
      "  int N = g.size();",
      "  vector<int> marked(N , 0) , temp(N , 0) , v;",
      "  auto visit = [&](auto f, int i) -> bool{",
      "    if(temp[i] == 1) return false;",
      "    if(marked[i] == 0){",
      "      temp[i] = 1;",
      "      for(auto &e : g[i]){",
      "        if(f(f , e) == false) return false;",
      "      }",
      "      marked[i] = 1;",
      "      v.push_back(i);",
      "      temp[i] = 0;",
      "    }",
      "    return true;",
      "  };",
      "",
      "  for(int i = 0 ; i < N ; i++){",
      "    if(marked[i] == 0) {",
      "      if(visit(visit , i) == false) return vector<int>();",
      "    }",
      "  }",
      "  reverse( v.begin() , v.end() );",
      "  return v;",
      "}"
    ],
    "description": "Topological_Sort"
  },
  "Simulated_Annealing": {
    "prefix": "_yakinamashi",
    "body": [
      "// Simulated Annealing(焼きなまし法)",
      "// 乱択アルゴリズムにより近似解を求めるアルゴリズム",
      "int calc();",
      "void SA(const clock_t start){",
      "  const double start_temp = 100.0;",
      "  const double end_temp = 10.0;",
      "  double cur_temp = start_temp;",
      "  const double limit = 1.8;",
      "  double cur_time = 0.0;",
      "  int times = 0;",
      "  auto score = calc();",
      "  while(1){",
      "    if(times % 100 == 0){",
      "      trc(times , score , cur_temp);",
      "      cur_time = double(clock() - start) / CLOCKS_PER_SEC;",
      "      if(cur_time > limit) break;",
      "      cur_temp = start_temp + (end_temp - start_temp) * cur_time / limit;",
      "    }",
      "    times++;",
      "    // 遷移",
      "    {",
      "",
      "    }",
      "    // scoreの再計算",
      "    decltype(score) nxt_score;",
      "",
      "    if( exp(double(nxt_score - score) / cur_temp) > rand_d() ){",
      "      // スコアの更新",
      "      score = nxt_score;",
      "    }",
      "    else{",
      "      // 復元",
      "",
      "    }",
      "  }",
      "  trc(times , score);",
      "}",
      ""
    ],
    "description": "Simulated_Annealing"
  },
  "ceiling": {
    "prefix": "_ceil",
    "body": [
      "template<typename T>inline T ceil(T a,T b){return (a + b - 1) / b;}"
    ],
    "description": "ceiling"
  },
  "LowLink": {
    "prefix": "_LowLink",
    "body": [
      "",
      "// LowLink, 橋と関節点の列挙 ",
      "// 橋(bridge) 取り除くとグラフを分断する辺",
      "// 関節点(articulation point) 取り除くとグラフを分断する節点",
      "template<typename T>",
      "struct LowLink{",
      "  int N;",
      "  const T &g;",
      "  vector<int> ord , low , articulation;",
      "  vector<pair<int,int> > bridge;",
      "  LowLink(const T &g) : g(g){",
      "    N = g.size();",
      "    ord.resize(N , -1);",
      "    low.resize(N , -1);",
      "    articulation.reserve(N);",
      "    bridge.reserve(N);",
      "    int k = 0;",
      "    for(int i = 0; i < N; i++){",
      "      if(!(~ord[i])) k = dfs(i , k , -1);",
      "    }",
      "    articulation.shrink_to_fit();",
      "    bridge.shrink_to_fit();",
      "  }",
      "  int dfs(int idx , int k , int par){",
      "    low[idx] = (ord[idx] = k++);",
      "    int cnt = 0;",
      "    bool is_arti = false;",
      "    for(auto &to : g[idx]){",
      "      if(ord[to] == -1){",
      "        cnt++;",
      "        k = dfs(to , k , idx);",
      "        low[idx] = min(low[idx] , low[to]);",
      "        is_arti |= (par != -1) && (low[to] >= ord[idx]);",
      "        if(ord[idx] < low[to]){",
      "          bridge.emplace_back(minmax(idx , (int)to));",
      "        }",
      "      }",
      "      else if(to != par){",
      "        low[idx] = min(low[idx] , ord[to]);",
      "      }",
      "    }",
      "    is_arti |= par == -1 && cnt > 1;",
      "    if(is_arti) articulation.push_back(idx);",
      "    return k;",
      "  }",
      "};",
      ""
    ],
    "description": "LowLink"
  },
  "Competitive_Programming_Template": {
    "prefix": "_tenpure",
    "body": [
      "#pragma region kyopro_template",
      "#include <bits/stdc++.h>",
      "#define pb push_back",
      "#define eb emplace_back",
      "#define fi first",
      "#define se second",
      "#define each(x, v) for (auto &x : v)",
      "#define all(v) (v).begin(), (v).end()",
      "#define sz(v) ((int)(v).size())",
      "#define mem(a, val) memset(a, val, sizeof(a))",
      "#define ini(...)   \\",
      "  int __VA_ARGS__; \\",
      "  in(__VA_ARGS__)",
      "#define inl(...)         \\",
      "  long long __VA_ARGS__; \\",
      "  in(__VA_ARGS__)",
      "#define ins(...)      \\",
      "  string __VA_ARGS__; \\",
      "  in(__VA_ARGS__)",
      "#define inc(...)    \\",
      "  char __VA_ARGS__; \\",
      "  in(__VA_ARGS__)",
      "#define in2(s, t)                           \\",
      "  for (int i = 0; i < (int)s.size(); i++) { \\",
      "    in(s[i], t[i]);                         \\",
      "  }",
      "#define in3(s, t, u)                        \\",
      "  for (int i = 0; i < (int)s.size(); i++) { \\",
      "    in(s[i], t[i], u[i]);                   \\",
      "  }",
      "#define in4(s, t, u, v)                     \\",
      "  for (int i = 0; i < (int)s.size(); i++) { \\",
      "    in(s[i], t[i], u[i], v[i]);             \\",
      "  }",
      "#define rep(i, N) for (long long i = 0; i < (long long)(N); i++)",
      "#define repr(i, N) for (long long i = (long long)(N)-1; i >= 0; i--)",
      "#define rep1(i, N) for (long long i = 1; i <= (long long)(N); i++)",
      "#define repr1(i, N) for (long long i = (N); (long long)(i) > 0; i--)",
      "#define die(...)      \\",
      "  do {                \\",
      "    out(__VA_ARGS__); \\",
      "    return;           \\",
      "  } while (0)",
      "",
      "",
      "using ll = long long;",
      "template <class T>",
      "using V = vector<T>;",
      "using vi = vector<int>;",
      "using vl = vector<long long>;",
      "using vvi = vector<vector<int>>;",
      "using vd = V<double>;",
      "using vs = V<string>;",
      "using vvl = vector<vector<long long>>;",
      "using P = pair<long long, long long>;",
      "using vp = vector<P>;",
      "using pii = pair<int, int>;",
      "using vpi = vector<pair<int, int>>;",
      "constexpr int inf = 1001001001;",
      "constexpr long long infLL = (1LL << 61) - 1;",
      "template <typename T, typename U>",
      "inline bool amin(T &x, U y) {",
      "  return (y < x) ? (x = y, true) : false;",
      "}",
      "template <typename T, typename U>",
      "inline bool amax(T &x, U y) {",
      "  return (x < y) ? (x = y, true) : false;",
      "}",
      "template <typename T, typename U>",
      "T ceil(T a, U b) {",
      "  return (a + b - 1) / b;",
      "}",
      "constexpr long long TEN(int n) {",
      "  long long ret = 1, x = 10;",
      "  while (n) {",
      "    if (n & 1) ret *= x;",
      "    x *= x;",
      "    n >>= 1;",
      "  }",
      "  return ret;",
      "}",
      "template <typename T, typename U>",
      "ostream &operator<<(ostream &os, const pair<T, U> &p) {",
      "  os << p.first << \" \" << p.second;",
      "  return os;",
      "}",
      "template <typename T, typename U>",
      "istream &operator>>(istream &is, pair<T, U> &p) {",
      "  is >> p.first >> p.second;",
      "  return is;",
      "}",
      "template <typename T>",
      "ostream &operator<<(ostream &os, const vector<T> &v) {",
      "  int s = (int)v.size();",
      "  for (int i = 0; i < s; i++) os << (i ? \" \" : \"\") << v[i];",
      "  return os;",
      "}",
      "template <typename T>",
      "istream &operator>>(istream &is, vector<T> &v) {",
      "  for (auto &x : v) is >> x;",
      "  return is;",
      "}",
      "void in() {}",
      "template <typename T, class... U>",
      "void in(T &t, U &... u) {",
      "  cin >> t;",
      "  in(u...);",
      "}",
      "void out() { cout << \"\\n\"; }",
      "template <typename T, class... U>",
      "void out(const T &t, const U &... u) {",
      "  cout << t;",
      "  if (sizeof...(u)) cout << \" \";",
      "  out(u...);",
      "}",
      "",
      "void solve();",
      "#ifdef NyaanDebug",
      "#include \"NyaanDebug.h\"",
      "#define trc(...)                   \\",
      "  do {                             \\",
      "    cerr << #__VA_ARGS__ << \" = \"; \\",
      "    dbg_out(__VA_ARGS__);          \\",
      "  } while (0)",
      "#define trca(v, N)       \\",
      "  do {                   \\",
      "    cerr << #v << \" = \"; \\",
      "    array_out(v, N);     \\",
      "  } while (0)",
      "#define trcc(v)                             \\",
      "  do {                                      \\",
      "    cerr << #v << \" = {\";                   \\",
      "    each(x, v) { cerr << \" \" << x << \",\"; } \\",
      "    cerr << \"}\" << endl;                    \\",
      "  } while (0)",
      "#else",
      "#define trc(...)",
      "#define trca(...)",
      "#define trcc(...)",
      "int main() { solve(); }",
      "#endif",
      "",
      "inline int popcnt(unsigned long long a) { return __builtin_popcountll(a); }",
      "inline int lsb(unsigned long long a) { return __builtin_ctzll(a); }",
      "inline int msb(unsigned long long a) { return 63 - __builtin_clzll(a); }",
      "template <typename T>",
      "inline int getbit(T a, int i) {",
      "  return (a >> i) & 1;",
      "}",
      "template <typename T>",
      "inline void setbit(T &a, int i) {",
      "  a |= (1LL << i);",
      "}",
      "template <typename T>",
      "inline void delbit(T &a, int i) {",
      "  a &= ~(1LL << i);",
      "}",
      "template <typename T>",
      "int lb(const vector<T> &v, const T &a) {",
      "  return lower_bound(begin(v), end(v), a) - begin(v);",
      "}",
      "template <typename T>",
      "int ub(const vector<T> &v, const T &a) {",
      "  return upper_bound(begin(v), end(v), a) - begin(v);",
      "}",
      "template <typename T>",
      "vector<T> mkrui(const vector<T> &v) {",
      "  vector<T> ret(v.size() + 1);",
      "  for (int i = 0; i < int(v.size()); i++) ret[i + 1] = ret[i] + v[i];",
      "  return ret;",
      "};",
      "template <typename T>",
      "vector<T> mkuni(const vector<T> &v) {",
      "  vector<T> ret(v);",
      "  sort(ret.begin(), ret.end());",
      "  ret.erase(unique(ret.begin(), ret.end()), ret.end());",
      "  return ret;",
      "}",
      "template <typename F>",
      "vector<int> mkord(int N, F f) {",
      "  vector<int> ord(N);",
      "  iota(begin(ord), end(ord), 0);",
      "  sort(begin(ord), end(ord), f);",
      "  return ord;",
      "}",
      "template <typename T = int>",
      "vector<T> mkiota(int N) {",
      "  vector<T> ret(N);",
      "  iota(begin(ret), end(ret), 0);",
      "  return ret;",
      "}",
      "template <typename T = int>",
      "vector<T> mkinv(vector<T> &v) {",
      "  vector<T> inv(v.size());",
      "  for (int i = 0; i < (int)v.size(); i++) inv[v[i]] = i;",
      "  return inv;",
      "}",
      "",
      "struct IoSetupNya {",
      "  IoSetupNya() {",
      "    cin.tie(nullptr);",
      "    ios::sync_with_stdio(false);",
      "    cout << fixed << setprecision(15);",
      "    cerr << fixed << setprecision(7);",
      "  }",
      "} iosetupnya;",
      "",
      "#pragma endregion",
      "",
      "constexpr int MOD = /** 998244353;  //*/ 1000000007;"
    ],
    "description": "Competitive_Programming_Template"
  },
  "grid_isexist": {
    "prefix": "_grid_isexist",
    "body": [
      "// gridライブラリに依存するライブラリ",
      "int h0,w0,h1,w1,h2,w2;",
      "// 存在する場合はh0,w0に場所を代入、trueを返す",
      "bool isExist(char cur){",
      "  rep(i,H) rep(j,W){",
      "    if(g[i][j] == cur){",
      "      h0 = i; w0 = j; return true;",
      "    }",
      "  }",
      "  return false;",
      "}",
      "",
      "// 存在する場合は 上端 h1 左端 w1 下端 h2 右端 w2　を代入、trueを返す",
      "// (h1,w1),(h2,w2)に存在するとは限らないことに注意",
      "bool isRange(char cur){",
      "  bool flg = false;",
      "  h1 = w1 = inf; h2 = w2 = -inf;",
      "  rep(i,H) rep(j,W){",
      "    if(g[i][j] == cur){",
      "      amin(h1 , i); amin(w1 , j);",
      "      amax(h2 , i); amax(w2 , j);",
      "      flg = true;",
      "    }",
      "  }",
      "  return flg;",
      "}"
    ],
    "description": "grid_isexist"
  },
  "grid_bfs": {
    "prefix": "_grid_bfs",
    "body": [
      "// 依存ライブラリ _grid",
      "// grid上を幅優先探索して距離を調べる",
      "void gbfs(vvi &d , pair<int,int> start){",
      "  using PP = pair<pair<int,int> , int>;",
      "  d.resize( H , vi(W , -1) );",
      "  queue<PP> Q;",
      "  Q.emplace( start , 0 );",
      "  while(!Q.empty()){",
      "    PP cur = Q.front(); Q.pop();",
      "    int x = cur.first.first , y = cur.first.second , dep = cur.second;",
      "    if(d[x][y] != -1) continue;",
      "    d[x][y] = dep;",
      "    rep(i , dn){",
      "      int dh = x + dx[i] , dw = y + dy[i];",
      "      if( ok(dh , dw) && d[dh][dw] == -1){",
      "        if( g[dh][dw] == '.' ){ // ここに条件を書く",
      "          Q.emplace( make_pair(dh , dw) , dep + 1 );",
      "        }",
      "      }",
      "    }",
      "  }",
      "}"
    ],
    "description": "grid_bfs"
  },
  "Dynamic_Fenwick_Tree(未完成)": {
    "prefix": "_DynamicBIT",
    "body": [
      "",
      "// idx_tはlong longまでを想定",
      "template<typename idx_t , typename data_t>",
      "struct DynamicFenwickTree{",
      "",
      "  idx_t N;",
      "  unordered_map< idx_t , data_t > data;",
      "  DynamicFenwickTree(idx_t size){ N = ++size; }",
      "",
      "  // iにxを加算",
      "  void add(idx_t k , data_t x){",
      "    for( k++; k < N; k += k & -k) data[k] += x;",
      "  }",
      "",
      "  // [0,i]のsum",
      "  data_t sum(idx_t k){",
      "    if(k < 0) return 0;",
      "    data_t ret = 0;",
      "    for( k++; k > 0; k -= k & -k) ret += data[k];",
      "    return ret;",
      "  }",
      "",
      "  // [a,b]のsum",
      "  data_t sum(idx_t a,idx_t b){return sum(b) - sum(a-1);}",
      "",
      "  idx_t lower_bound(data_t w){",
      "    if(w <= 0) return 0;",
      "    idx_t x = 0;",
      "    for(idx_t k = 1 << (63 - __builtin_clzll( (long long)(x) ) ); k > 0; k /= 2){",
      "      if(x + k <= N - 1 && data[x + k] < w){",
      "        w -= data[x + k];",
      "        x += k;",
      "      }",
      "    }",
      "    return x;    ",
      "  }",
      "",
      "  void merge(DynamicFenwickTree<idx_t,data_t>& other){",
      "    if(data.size() < other.data.size()) data.swap(other.data);",
      "    for( auto &x : other.data) data[x.fi] += x.se;",
      "  }",
      "",
      "};",
      ""
    ],
    "description": "Dynamic_Fenwick_Tree"
  },
  "Shakutori": {
    "prefix": "_Shakutori",
    "body": [
      "// 尺取り法",
      "  // 和がS以上となる連続部分列のうち最小の長さのものを全探索する",
      "  auto shakutori = [&](int N, auto S, auto& a){",
      "    // 状態を閉区間で持つ",
      "    int l = 0 , r = 0;",
      "    auto cur = a[0];",
      "    while(l != N){",
      "      if(cur >= S){",
      "        // cur >= Sの時の処理",
      "        cur -= a[l]; l++;",
      "      }",
      "      else if(r == N - 1) return;",
      "      else {r++; cur += a[r]; }",
      "    }",
      "  };"
    ],
    "description": "Shakutori"
  },
  "Digit": {
    "prefix": "_digit",
    "body": [
      "",
      "// Nが正の数の時は桁数を、0以下の時は0を返す",
      "int digit(long long N){",
      "  int ret = 0;",
      "  while(N > 0) ret++ , N /= 10;",
      "  return ret;",
      "}"
    ],
    "description": "Digit"
  },
  "grid_dijkstra": {
    "prefix": "_grid_dijkstra",
    "body": [
      "// 依存ライブラリ _grid",
      "// grid上のdijkstra法で最短距離を調べる",
      "template<typename T>",
      "void gdijk(vector<vector< T > > &d , pair<int,int> start){",
      "  using PP = pair< T , pair<int,int> >;",
      "  d.clear();",
      "  d.resize( H , vector<T>(W , -1) );",
      "  priority_queue< PP,vector<PP>,greater<PP> > Q;",
      "  Q.emplace( 0 , start );",
      "  while(!Q.empty()){",
      "    PP cur = Q.top(); Q.pop();",
      "    int x = cur.second.first , y = cur.second.second;",
      "    T dep = cur.first;",
      "    if(d[x][y] != -1) continue;",
      "    d[x][y] = dep;",
      "    rep(i , dn){",
      "      int dh = x + dx[i] , dw = y + dy[i];",
      "      if( ok(dh , dw) && d[dh][dw] == -1){",
      "        if( g[dh][dw] == '.' ){ // ここに条件を書く",
      "          Q.emplace( dep + 1 , make_pair(dh , dw) );",
      "        }",
      "      }",
      "    }",
      "  }",
      "}"
    ],
    "description": "grid_dijkstra"
  },
  "float_bicom": {
    "prefix": "_bicom_float",
    "body": [
      "struct float_bicom{",
      "  vector<long double> fac;",
      "  float_bicom(int MAX){",
      "    fac.resize(MAX + 1, 1.0);",
      "    fac[0] = 1.0;",
      "    for(int i = 1; i <= MAX; i++){",
      "      fac[i] = fac[i - 1] * i;",
      "    }",
      "  }",
      "  long double C(int n , int k){",
      "    if(n < k || k < 0 || n < 0) return 0.0;",
      "    return fac[n] / fac[n - k] / fac[k];",
      "  }",
      "  long double P(int n , int k){",
      "    if(n < k || k < 0 || n < 0) return 0.0;",
      "    return fac[n] / fac[n - k];",
      "  }",
      "};"
    ],
    "description": "float_bicom"
  },
  "Sparse_Table": {
    "prefix": "_SparseTable",
    "body": [
      "",
      "// Sparse Table",
      "template<typename T>",
      "struct SparseTable{",
      "  vector< vector< T > > table;",
      "  vector< int > log_table;",
      "",
      "  SparseTable(const vector< T > &v) {",
      "    int b = 0;",
      "    while((1 << b) <= (int)v.size()) ++b;",
      "    table.assign(b, vector< T >(1 << b));",
      "    for(int i = 0; i < (int)v.size(); i++) {",
      "      table[0][i] = v[i];",
      "    }",
      "    for(int i = 1; i < b; i++) {",
      "      for(int j = 0; j + (1 << i) <= (1 << b); j++) {",
      "        table[i][j] = min(table[i - 1][j], table[i - 1][j + (1 << (i - 1))]);",
      "      }",
      "    }",
      "    log_table.resize(v.size() + 1);",
      "    for(int i = 2; i < (int)log_table.size(); i++) {",
      "      log_table[i] = log_table[i >> 1] + 1;",
      "    }",
      "  }",
      "",
      "  // 区間 [l , r) の最小値を返す",
      "  inline T query(int l, int r) {",
      "    int b = log_table[r - l];",
      "    return min(table[b][l], table[b][r - (1 << b)]);",
      "  }",
      "};"
    ],
    "description": "Sparse_Table"
  },
  "Suffix_Array": {
    "prefix": "_SuffixArray",
    "body": [
      "// Suffix Array",
      "//verify https://judge.yosupo.jp/submission/240",
      "struct SuffixArray{",
      "  int _size;",
      "  vector<int> sa;",
      "  string &s;",
      "  SuffixArray(string &str):_size(str.size()) , s(str) {",
      "    // うしさんのO( N logN )の実装",
      "    s.push_back(0);",
      "    sa.resize(s.size());",
      "    iota(begin(sa), end(sa), 0);",
      "    sort(begin(sa), end(sa), [&](int a, int b) {",
      "      return s[a] == s[b] ? a > b : s[a] < s[b];",
      "    });",
      "    vector< int > classes(s.size()), c(s.begin(), s.end()), cnt(s.size());",
      "    for(int len = 1; len < (int)s.size(); len <<= 1) {",
      "      for(int i = 0; i < (int)s.size(); i++) {",
      "        if(i > 0 && c[sa[i - 1]] == c[sa[i]] && sa[i - 1] + len < (int)s.size() && c[sa[i - 1] + len / 2] == c[sa[i] + len / 2]) {",
      "          classes[sa[i]] = classes[sa[i - 1]];",
      "        } else {",
      "          classes[sa[i]] = i;",
      "        }",
      "      }",
      "      iota(begin(cnt), end(cnt), 0);",
      "      copy(begin(sa), end(sa), begin(c));",
      "      for(int i = 0; i < (int)s.size(); i++) {",
      "        int s1 = c[i] - len;",
      "        if(s1 >= 0) sa[cnt[classes[s1]]++] = s1;",
      "      }",
      "      classes.swap(c);",
      "    }",
      "    s.pop_back();",
      "  }",
      "  // デバッグ用に実装",
      "  void output() {",
      "    cout << \"SA\\tidx\\tstr\" << endl;",
      "    for(int i = 0; i < size(); i++) {",
      "      cout << i << \": \\t\" << sa[i] << \" \\t\" ;",
      "      if(sa[i] != _size) cout << s.substr(sa[i],_size - sa[i]) << endl;",
      "      else cout << \"$\" << endl;",
      "    }",
      "    cout << endl;",
      "  }",
      "  // sa.size()と表せると便利なので実装",
      "  int size() const{return _size + 1;}",
      "  // sa[]と表せると便利なのでオーバーロードしておく",
      "  int operator[](int k) const{return sa[k]; }",
      "};",
      "",
      "struct LCPArray {",
      "  const SuffixArray &SA;",
      "  vector<int> LCP, rank;",
      "  LCPArray(const SuffixArray &sa) : SA(sa) {",
      "    LCP.resize(SA.size()); rank.resize(SA.size());",
      "    // 初期化　rankはsaの逆関数",
      "    for(int i = 0; i < SA.size(); i++) {",
      "      rank[SA[i]] = i;",
      "    }",
      "    LCP[0] = 0; ",
      "    ",
      "    // 構築",
      "    for(int i = 0, h = 0; i < SA.size() - 1 ; i++) {",
      "      int j = SA[rank[i] - 1] ; h ? h-- : h;",
      "      // ここで尺取り法に近い手法を使うことでO(N)でLCPの構築をしている",
      "      while( (i > j ? i : j) + h < SA.size() - 1 && SA.s[i + h] == SA.s[j + h] && ++h );",
      "      LCP[rank[i] - 1] = h;",
      "    }",
      "  }",
      "",
      "  // デバッグ用に実装",
      "  void output() {",
      "    cout << \"SA\\tidx\\tLCP\\tstr\" << endl;",
      "     for(int i = 0 ; i < SA.size() ; i++){",
      "      cout << i << \"\\t\" << SA[i] <<\" \\t\" << LCP[i] << \"\\t\"; ",
      "      if(SA[i] == SA.size() - 1) cout << \"$\";",
      "      else cout << SA.s.substr(SA[i] , SA.size() - 1 - SA[i]);",
      "      cout << endl;",
      "    }",
      "  }",
      "",
      "};",
      "",
      "// Sparse Table",
      "template<typename T>",
      "struct SparseTable{",
      "  vector< vector< T > > table;",
      "  vector< int > log_table;",
      "",
      "  SparseTable(const vector< T > &v) {",
      "    int b = 0;",
      "    while((1 << b) <= (int)v.size()) ++b;",
      "    table.assign(b, vector< T >(1 << b));",
      "    for(int i = 0; i < (int)v.size(); i++) {",
      "      table[0][i] = v[i];",
      "    }",
      "    for(int i = 1; i < b; i++) {",
      "      for(int j = 0; j + (1 << i) <= (1 << b); j++) {",
      "        table[i][j] = min(table[i - 1][j], table[i - 1][j + (1 << (i - 1))]);",
      "      }",
      "    }",
      "    log_table.resize(v.size() + 1);",
      "    for(int i = 2; i < (int)log_table.size(); i++) {",
      "      log_table[i] = log_table[i >> 1] + 1;",
      "    }",
      "  }",
      "",
      "  // 区間 [l , r) の最小値を返す",
      "  inline T query(int l, int r) {",
      "    int b = log_table[r - l];",
      "    return min(table[b][l], table[b][r - (1 << b)]);",
      "  }",
      "};",
      "",
      "// 文字列検索 検索 O(M + logN) メモリO(N logN)",
      "// verify",
      "// https://onlinejudge.u-aizu.ac.jp/status/users/NyaanNyaan/submissions/1/ALDS1_14_D/judge/3874273/C++14",
      "// https://atcoder.jp/contests/abc135/submissions/7574225",
      "// https://judge.yosupo.jp/submission/241",
      "// https://atcoder.jp/contests/abc141/submissions/7577295",
      "struct StringSearch{",
      "  string &s;",
      "  const SuffixArray &sa;",
      "  const LCPArray &lcp;",
      "  SparseTable<int> sparse;",
      "  StringSearch(LCPArray &lcp)",
      "    : s(lcp.SA.s) , sa(lcp.SA) , lcp(lcp) , sparse(lcp.LCP){ }",
      "",
      " // 文字列sの[i , N)と[j , N)の共通接頭辞の長さを求める",
      "  int ArbitaryLCP(int i , int j){",
      "    if(i == j) return (int)(s.size()) - i;",
      "    return sparse.query(",
      "      min(lcp.rank[i] , lcp.rank[j]) , ",
      "      max(lcp.rank[i] , lcp.rank[j])  ",
      "    );",
      "  }",
      "",
      "  pair<int,int> comp(const string &t  , int len , int si , int ti = 0){",
      "    int sn = (int)s.size() , tn = (int) t.size();",
      "    si += len , ti += len;",
      "    while(si < sn && ti < tn){",
      "      if(s[si] != t[ti]) return make_pair( s[si]<t[ti] , ti);",
      "      si++ , ti++;",
      "    }",
      "    return make_pair( (si>=sn && ti<tn) , ti);",
      "  }  ",
      "",
      "  pair<int,int> find_range(int left , int med , int right , int len){",
      "    {",
      "      int ng = left - 1, ok = med;",
      "      while(ng + 1 < ok){",
      "        int cur = (ng + ok) / 2;",
      "        if(sparse.query(cur , med) >= len) ok = cur;",
      "        else ng = cur;",
      "      }",
      "      left = ok;",
      "    }",
      "    {",
      "      int ok = med , ng = right + 1;",
      "      while(ok + 1 < ng){",
      "        int cur = (ng + ok) / 2;",
      "        if(sparse.query(med, cur) >= len) ok = cur;",
      "        else ng = cur;",
      "      }",
      "      right = ok;",
      "    }",
      "    return make_pair(left , right);",
      "  }",
      "",
      "  // 全ての出現範囲をSA上の[left , right]の範囲で返す",
      "  // 存在しない場合は-1を返す",
      "  pair<int,int> find(string &t){",
      "    // 条件を満たす[left , right]を見つける",
      "    // sa[0]は空文字列なので left = 1 とする",
      "    // lenは既に一致している文字列の長さ",
      "    int left = 1 , right = sa.size() - 1 , med = left;",
      "    int leftlen = 0 , rightlen = 0 , tlen = t.size();",
      "    pair<int,int> ret;",
      "    while(left + 1 < right){",
      "      med = (left + right) / 2;",
      "",
      "      int corres_len = max(",
      "        min(leftlen , sparse.query(left , med)) ,",
      "        min(rightlen, sparse.query(med , right))",
      "      );",
      "      if(corres_len < max(leftlen , rightlen)){",
      "        if(leftlen < rightlen) ",
      "          left = med , leftlen = corres_len;",
      "        else",
      "          right= med ,rightlen = corres_len;",
      "        continue;",
      "      }",
      "      ret = comp(t , corres_len , sa[med]);",
      "      //trc(left,med,right,ret);",
      "      if(ret.second == tlen)",
      "        return find_range(left,med,right,tlen);",
      "      if(ret.first == 0)",
      "        right = med , rightlen = ret.second;",
      "      else",
      "        left = med , leftlen = ret.second;",
      "    }",
      "    if(sa.size() <= 3){",
      "      if(comp(t,0,sa[left]).second==tlen) return find_range(left,left,right,tlen);",
      "      if(comp(t,0,sa[right]).second==tlen) return find_range(left,right,right,tlen);",
      "      return make_pair(-1,-1);",
      "    }",
      "    med = left + right - med;",
      "    ret = comp(t , min(leftlen,rightlen) , sa[med]);",
      "    //trc(left,med,right,ret);",
      "    if(ret.second == tlen)",
      "      return find_range(left,med,right,tlen);",
      "    return make_pair(-1,-1);",
      "  }",
      "};",
      "",
      "// Suffix Arrayの使い方(メモリを食うので必要なものだけ使う)",
      "// 参照があるのでstringを削除などしないこと",
      "/*",
      "  SuffixArray sa(S);",
      "  LCPArray lcp(sa);",
      "  StringSearch search(lcp);",
      "*/"
    ],
    "description": "Suffix_Array"
  },
  "Divisor_Multiple_Transform": {
    "prefix": "_divisor_multiple_transform",
    "body": [
      "",
      "struct divisor_transform{",
      "  template <typename T>",
      "  static constexpr void zeta_transform(vector<T> &a){",
      "    int N = a.size() - 1; ",
      "    vector<int> sieve(N + 1, true);",
      "    for(int p = 2; p <= N; p++)",
      "      if(sieve[p])",
      "        for(int k = 1; k * p <= N; ++k)",
      "          sieve[k * p] = false , a[k * p] += a[k];    ",
      "  }",
      "",
      "  template<typename T>",
      "  static constexpr void mobius_transform(T &a){",
      "    int N = a.size() - 1; ",
      "    vector<int> sieve(N + 1, true);",
      "    for(int p = 2; p <= N; p++)",
      "      if(sieve[p])",
      "        for(int k = N / p; k > 0; --k)",
      "          sieve[k * p] = false , a[k * p] -= a[k];    ",
      "  }",
      "  ",
      "  // verify ",
      "  // https://atcoder.jp/contests/arc064/submissions/7707249",
      "  template<typename T>",
      "  static constexpr void zeta_transform(map<long long, T> &a){",
      "    for(auto &x : a) for(auto &y : a){",
      "      if(x == y) break;",
      "      if(x.first % y.first == 0) x.second += y.second;",
      "    }",
      "  }",
      "  template<typename T>",
      "  static constexpr void mobius_transform(map<long long, T> &a){",
      "    for(auto &x : a) for(auto &y : a){",
      "      if(x == y) break;",
      "      if(x.first % y.first == 0) x.second -= y.second;",
      "    }",
      "  }",
      "",
      "};",
      "",
      "// verify",
      "// https://atcoder.jp/contests/agc038/submissions/7683063",
      "// https://www.codechef.com/viewsolution/26767783",
      "struct multiple_transform{",
      "  template <typename T>",
      "  static constexpr void zeta_transform(vector<T> &a){",
      "    int N = a.size() - 1;",
      "    vector<int> sieve(N + 1, true);",
      "    for(int p = 2; p <= N; ++p)",
      "      if(sieve[p])",
      "        for(int k = N / p; k > 0; --k)",
      "          sieve[k * p] = false , a[k] += a[k * p];",
      "  }",
      "  template <typename T>",
      "  static constexpr void mobius_transform(vector<T> &a){",
      "    int N = a.size() - 1;",
      "    vector<int> sieve(N + 1, true);",
      "    for(int p = 2; p <= N; ++p)",
      "      if(sieve[p])",
      "        for(int k = 1; k * p <= N; ++k)",
      "          sieve[k * p] = false , a[k] -= a[k * p];",
      "  }",
      "",
      "  template<typename T>",
      "  static constexpr void zeta_transform(map<long long, T> &a){",
      "    for(auto it=a.rbegin(); it!=a.rend(); it++)",
      "      for(auto it2=a.rbegin(); it2!=it; it2++)",
      "        if(it2->first % it->first == 0)",
      "          it->second += it2->second;",
      "  }",
      "  template<typename T>",
      "  static constexpr void mobius_transform(map<long long, T> &a){",
      "    for(auto it=a.rbegin(); it!=a.rend(); it++)",
      "      for(auto it2=a.rbegin(); it2!=it; it2++)",
      "        if(it2->first % it->first == 0)",
      "          it->second -= it2->second;",
      "  }",
      "",
      "};",
      "",
      "template<typename T>",
      "static constexpr vector<T> mobius_function(int N){",
      "  vector<T> a(N + 1 , 0);",
      "  a[1] = 1;",
      "  divisor_transform::mobius_transform(a);",
      "  return a;",
      "}",
      "",
      "template<int N>",
      "struct constexpr_mobius_function{",
      "  int mobius[N + 1] , sieve[N + 1];",
      "  constexpr constexpr_mobius_function(): mobius() , sieve(){",
      "    for(int i=1; i<=N; i++) sieve[i] = 1, mobius[i] = 0;",
      "    mobius[1] = 1;",
      "    for(int p = 2; p <= N; p++)",
      "      if(sieve[p])",
      "        for(int k = N / p; k > 0; --k)",
      "          sieve[k * p] = false , mobius[k * p] -= mobius[k];    ",
      "  }",
      "  const int& operator[](int i)const{return mobius[i];}",
      "};",
      "",
      "// N = 1000000 , pnum = 78498",
      "template<int N,int pnum> struct constexpr_prime{",
      "  int prime[pnum];",
      "  int sieve[N + 1];",
      "  constexpr_prime() : prime() , sieve() {",
      "    for(int i=2;i<=N;i++) sieve[i]=1;",
      "    int idx = 0;",
      "    for(long long p = 2; p <= N; p++){",
      "      if(sieve[p]){",
      "        prime[idx++] = p;",
      "        for(long long j = p * p; j <= N; j += p) sieve[j] = 0;",
      "      }",
      "    }",
      "  }",
      "  const long long& operator[](long long i) const{return prime[i];}",
      "};",
      "",
      "// verify",
      "template<typename T,typename F>",
      "static constexpr unordered_map<long long,T> divisor_zeta_transform(long long N, F f){",
      "  // factorization",
      "  unordered_map<long long,long long> factors;",
      "  {",
      "    long long M = N;",
      "    for(long long i = 2; i * i <= M; i++)",
      "      while(M % i == 0) factors[i]++ , M /= i;",
      "    if(M != 1) factors[M]++;",
      "  }",
      "  unordered_map<long long,T> ret;",
      "  ret.emplace(1 , 1);",
      "  for(auto &d : factors){",
      "    auto ret2 = ret;",
      "    T prev = 1;",
      "    for(long long i = 1 , cur = d.first; ",
      "      i <= d.second;",
      "      i++ , cur *= d.first){",
      "      T val = ( prev += f(cur) );",
      "      for(auto &x : ret) ",
      "        ret2.emplace(x.first*cur , x.second*val);",
      "    }",
      "    swap(ret , ret2);",
      "  }",
      "  return ret;",
      "}",
      "",
      "// verify",
      "// https://onlinejudge.u-aizu.ac.jp/status/users/NyaanNyaan/submissions/1/NTL_1_D/judge/3892694/C++14",
      "// https://atcoder.jp/contests/abc020/submissions/7695313",
      "template<typename T,typename F>",
      "static constexpr unordered_map<long long,T> divisor_mobius_transform(long long N, F f){",
      "  // factorization",
      "  unordered_map<long long,long long> factors;",
      "  {",
      "    long long M = N;",
      "    for(long long i = 2; i * i <= M; i++)",
      "      while(M % i == 0) factors[i]++ , M /= i;",
      "    if(M != 1) factors[M]++;",
      "  }",
      "  unordered_map<long long,T> ret;",
      "  ret.emplace(1 , 1);",
      "  for(auto &d : factors){",
      "    auto ret2 = ret;",
      "    for(long long i = 1,cur = d.first , prev = 1; ",
      "      i <= d.second; ",
      "      i++ , cur *= d.first , prev *= d.first){",
      "      T val = f(cur) - f(prev);",
      "      for(auto &x : ret) ",
      "        ret2.emplace(x.first*cur , x.second*val);",
      "    }",
      "    swap(ret , ret2);",
      "  }",
      "  return ret;",
      "}",
      ""
    ],
    "description": "Divisor_Multiple_Transform"
  },
  "Algebra_Library": {
    "prefix": "_daisu",
    "body": [
      "// Prime -> 1 {0, 0, 1, 1, 0, 1, 0, 1, ...}",
      "vector<int> Primes(int N) {",
      "  vector<int> A(N + 1, 1);",
      "  A[0] = A[1] = 0;",
      "  for (int i = 2; i * i <= N; i++)",
      "    if (A[i] == 1)",
      "      for (int j = i << 1; j <= N; j += i) A[j] = 0;",
      "  return A;",
      "}",
      "",
      "// Prime Sieve {2, 3, 5, 7, 11, 13, 17, ...}",
      "vector<long long> PrimeSieve(int N) {",
      "  vector<int> prime = Primes(N);",
      "  vector<long long> ret;",
      "  for (int i = 0; i < (int)prime.size(); i++)",
      "    if (prime[i] == 1) ret.push_back(i);",
      "  return ret;",
      "}",
      "",
      "// Factors (using for fast factorization)",
      "// {0, 0, 1, 1, 2, 1, 2, 1, 2, 3, ...}",
      "vector<int> Factors(int N) {",
      "  vector<int> A(N + 1, 1);",
      "  A[0] = A[1] = 0;",
      "  for (int i = 2; i * i <= N; i++)",
      "    if (A[i] == 1)",
      "      for (int j = i << 1; j <= N; j += i) A[j] = i;",
      "  return A;",
      "}",
      "",
      "// totient function φ(N)=(1 ~ N , gcd(i,N) = 1)",
      "// {0, 1, 1, 2, 4, 2, 6, 4, ... }",
      "vector<int> EulersTotientFunction(int N) {",
      "  vector<int> ret(N + 1, 0);",
      "  for (int i = 0; i <= N; i++) ret[i] = i;",
      "  for (int i = 2; i <= N; i++) {",
      "    if (ret[i] == i)",
      "      for (int j = i; j <= N; j += i) ret[j] = ret[j] / i * (i - 1);",
      "  }",
      "  return ret;",
      "}",
      "",
      "// Divisor ex) 12 -> {1, 2, 3, 4, 6, 12}",
      "vector<long long> Divisor(long long N) {",
      "  vector<long long> v;",
      "  for (long long i = 1; i * i <= N; i++) {",
      "    if (N % i == 0) {",
      "      v.push_back(i);",
      "      if (i * i != N) v.push_back(N / i);",
      "    }",
      "  }",
      "  return v;",
      "}",
      "",
      "// Factorization",
      "// ex) 18 -> { (2,1) , (3,2) }",
      "vector<pair<long long, int> > PrimeFactors(long long N) {",
      "  vector<pair<long long, int> > ret;",
      "  for (long long p = 2; p * p <= N; p++)",
      "    if (N % p == 0) {",
      "      ret.emplace_back(p, 0);",
      "      while (N % p == 0) N /= p, ret.back().second++;",
      "    }",
      "  if (N >= 2) ret.emplace_back(N, 1);",
      "  return ret;",
      "}",
      "",
      "// Factorization with Prime Sieve",
      "// ex) 18 -> { (2,1) , (3,2) }",
      "vector<pair<long long, int> > PrimeFactors(long long N,",
      "                                           const vector<long long> &prime) {",
      "  vector<pair<long long, int> > ret;",
      "  for (auto &p : prime) {",
      "    if (p * p > N) break;",
      "    if (N % p == 0) {",
      "      ret.emplace_back(p, 0);",
      "      while (N % p == 0) N /= p, ret.back().second++;",
      "    }",
      "  }",
      "  if (N >= 2) ret.emplace_back(N, 1);",
      "  return ret;",
      "}",
      "",
      "// modpow for mod < 2 ^ 31",
      "long long modpow(long long a, long long n, long long mod) {",
      "  a %= mod;",
      "  long long ret = 1;",
      "  while (n > 0) {",
      "    if (n & 1) ret = ret * a % mod;",
      "    a = a * a % mod;",
      "    n >>= 1;",
      "  }",
      "  return ret % mod;",
      "};",
      "",
      "// Check if r is Primitive Root",
      "bool isPrimitiveRoot(long long r, long long mod) {",
      "  r %= mod;",
      "  if (r == 0) return false;",
      "  auto pf = PrimeFactors(mod - 1);",
      "  for (auto &x : pf) {",
      "    if (modpow(r, (mod - 1) / x.first, mod) == 1) return false;",
      "  }",
      "  return true;",
      "}",
      "",
      "// Get Primitive Root",
      "long long PrimitiveRoot(long long mod) {",
      "  long long ret = 1;",
      "  while (isPrimitiveRoot(ret, mod) == false) ret++;",
      "  return ret;",
      "}",
      "",
      "// Extended Euclidean algorithm",
      "// solve : ax + by = gcd(a, b)",
      "long long extgcd(long long a, long long b, long long &x, long long &y) {",
      "  if (b == 0) {",
      "    x = 1;",
      "    y = 0;",
      "    return a;",
      "  }",
      "  long long d = extgcd(b, a % b, y, x);",
      "  y -= a / b * x;",
      "  return d;",
      "}",
      "",
      "// Check if n is Square Number",
      "bool isSquare(ll n) {",
      "  if(n == 0 || n == 1) return true;",
      "  ll d = (ll)sqrt(n) - 1;",
      "  while (d * d < n) ++d;",
      "  return d * d == n;",
      "}",
      "",
      "// return a number of n's digit",
      "// zero ... return value if n = 0 (default -> 1)",
      "int isDigit(ll n, int zero = 1) {",
      "  if (n == 0) return zero;",
      "  int ret = 0;",
      "  while (n) {",
      "    n /= 10;",
      "    ret++;",
      "  }",
      "  return ret;",
      "}"
    ],
    "description": "Algebra_Library"
  },
  "Li_Chao_Tree": {
    "prefix": "_LiChaoTree",
    "body": [
      "template<typename T, T INF>",
      "struct LiChaoTree{",
      "",
      "  struct Line{",
      "    T slope , intercept;",
      "    Line(T slope,T intercept) : slope(slope),intercept(intercept){}",
      "    inline T get(T x) const{",
      "      return slope * x + intercept;",
      "    }",
      "    inline bool over(const Line& other , const T &x) const{",
      "      return get(x) < other.get(x);",
      "    }",
      "  };",
      "",
      "  // remind セグ木は0-indexedの実装",
      "  vector<T> xset;",
      "  vector<Line> seg;",
      "  int _size;",
      "",
      "  // 引数xにはx座標の集合を入れる",
      "  LiChaoTree(const vector<T> &x) : xset(x) {",
      "    sort( xset.begin() , xset.end() );",
      "    xset.erase( unique(xset.begin() , xset.end() ) , xset.end() );",
      "    _size = 1; while( _size < (int)xset.size() ) _size <<= 1;",
      "    while( (int)xset.size() < _size ) xset.push_back(xset.back() + 1);",
      "    seg.assign( 2 * _size , Line(0, INF) );",
      "  }",
      "",
      "  // 以上 xset[max]以下であることを仮定",
      "  int get_more_idx(T k){ ",
      "    return lower_bound( xset.begin() , xset.end() , k ) - xset.begin();",
      "  }",
      "  // 以下 xset[0]以上であることを仮定",
      "  int get_less_idx(T k){",
      "    int ret = upper_bound( xset.begin() , xset.end() , k ) - xset.begin();",
      "    return max(0 , ret - 1);",
      "  }",
      "",
      "  // 内部用",
      "  void inner_update(T a, T b, int left, int right, int seg_idx){",
      "    Line line(a , b);",
      "    while(1){",
      "      int mid = (left + right) >> 1;",
      "      bool l_over = line.over(seg[seg_idx], xset[left] );",
      "      bool r_over = line.over(seg[seg_idx], xset[right-1] );",
      "      if(l_over == r_over){",
      "        if(l_over) swap(seg[seg_idx] , line);",
      "        return;",
      "      }",
      "      bool m_over = line.over(seg[seg_idx], xset[mid] );",
      "      if(m_over) swap(seg[seg_idx], line);",
      "      if(l_over != m_over) seg_idx = (seg_idx << 1) , right = mid;",
      "      else seg_idx = (seg_idx<<1) | 1 , left = mid;",
      "    }",
      "  }",
      "",
      "  // 内部用",
      "  void inner_update(T a, T b, int seg_idx){ ",
      "    int left , right;",
      "    int upper_bit =  31 - __builtin_clz(seg_idx);",
      "    left = (_size >> upper_bit) * (seg_idx - (1 << upper_bit) );",
      "    right = left + (_size >> upper_bit);",
      "    inner_update(a , b , left , right , seg_idx);",
      "  }",
      "  ",
      "  // y = ax + bなる直線を追加",
      "  void update(T a, T b){",
      "    inner_update(a , b , 0 , _size , 1);",
      "  }",
      "",
      "  // 閉区間x in [left , right]に線分y = ax + bを追加するクエリ",
      "  void update_line_segment(T a,T b,T low,T high){",
      "    int left = get_more_idx(low) + _size;",
      "    int right= get_less_idx(high)+ _size + 1;",
      "    for( ; left < right; left >>= 1 , right >>= 1){",
      "      if(left & 1) inner_update(a , b , left++);",
      "      if(right& 1) inner_update(a , b , --right); ",
      "    }",
      "  }",
      "",
      "  T inner_query(int x , int segidx){",
      "    T ret = seg[segidx].get(x);",
      "    while(segidx > 1){",
      "      segidx = segidx >> 1;",
      "      ret = min(ret , seg[segidx].get(x) );",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  // x = xset[k]なる点における最小値クエリ",
      "  T query_idx(int k) {",
      "    const T x = xset[k];",
      "    k += _size;",
      "    return inner_query(x , k);",
      "  }",
      "",
      "  // xにおける最小クエリ",
      "  T query(T x){ return query_idx( get_more_idx(x) ); }",
      "  ",
      "};"
    ],
    "description": "Li_Chao_Tree"
  },
  "Dynamic_Li_Chao_Tree": {
    "prefix": "_dynamiclichao",
    "body": [
      "",
      "template<typename T , T INF>",
      "struct DynamicLiChaoTree{",
      " ",
      "  struct Line{",
      "    T slope , intercept;",
      "    Line() : slope(0),intercept(INF){}",
      "    Line(T slope,T intercept) : slope(slope),intercept(intercept){}",
      "    inline T get(T x) const{",
      "      return slope * x + intercept;",
      "    }",
      "    inline bool over(const Line& other , const T &x) const{",
      "      return get(x) < other.get(x);",
      "    }",
      "  };",
      " ",
      "  // remind セグ木は1-indexedの実装",
      "  T xmin, xmax, _size;",
      "  unordered_map<T, Line> seg;",
      " ",
      "  // [l , r]におけるLi Chao Tree",
      "  DynamicLiChaoTree(T xmin, T xmax) : xmin(xmin), xmax(xmax){",
      "    _size = 1; while(_size < xmax - xmin + 1) _size <<= 1;",
      "  }",
      "  ",
      "  // 内部用の関数",
      "  void update(T a,T b,T left,T right,T seg_idx){",
      "    Line line(a , b);",
      "    while(1){",
      "      T mid = (left + right) >> 1;",
      "      bool l_over = line.over(seg[seg_idx], min(xmax , left   + xmin) );",
      "      bool r_over = line.over(seg[seg_idx], min(xmax , right-1+ xmin) );",
      "      if(l_over == r_over){",
      "        if(l_over) swap(seg[seg_idx] , line);",
      "        return;",
      "      }",
      "      bool m_over = line.over(seg[seg_idx], min(xmax , mid + xmin) );",
      "      if(m_over) swap(seg[seg_idx], line);",
      "      if(l_over != m_over) seg_idx = (seg_idx << 1) , right = mid;",
      "      else seg_idx = (seg_idx<<1) | 1 , left = mid;",
      "    }",
      "  }",
      "  // 内部用の関数",
      "  void update(T a, T b, T seg_idx){ ",
      "    T left , right;",
      "    T upper_bit =  63 - __builtin_clzll(seg_idx);",
      "    left = (_size >> upper_bit) * (seg_idx - (1 << upper_bit) );",
      "    right = left + (_size >> upper_bit);",
      "    update(a , b , left , right , seg_idx);",
      "  }",
      "  /*",
      "  void update(T a,T b,T left,T right){",
      "    T lower_bit = (left | right) & (- (left | right) );",
      "    T seg_idx = ( _size + left ) / lower_bit;",
      "    update(a , b , left , right , seg_idx);",
      "  }",
      "  */",
      "  // y = ax + bなる直線を追加",
      "  void update(T a, T b){",
      "    update(a , b , 0 , _size , 1);",
      "  }",
      "",
      "  // 閉区間x in [left , right]に線分y = ax + bを追加するクエリ",
      "  void update_line_segment(T a,T b,T left,T right){",
      "    left -= xmin - _size, right -= xmin - _size - 1;",
      "    for( ; left < right; left >>= 1 , right >>= 1){",
      "      if(left & 1) update(a , b , left++);",
      "      if(right& 1) update(a , b , --right); ",
      "    }",
      "  }",
      "",
      "  // xにおける最小値クエリ",
      "  T query(T x) {",
      "    T left = 0 , right = _size , seg_idx = 1 , idx = x - xmin , ret = INF;",
      "    while(1){",
      "      T cur = seg[seg_idx].get(x);",
      "      // 線分追加クエリがない場合はここのコメントアウトを外して高速化可能(1.5倍程度？)",
      "      //if(cur == INF) break;",
      "      ret = min(ret , cur);",
      "      if(left + 1 >= right) break;",
      "      T mid = (left + right) >> 1;",
      "      if(idx < mid) seg_idx = (seg_idx << 1) , right = mid;",
      "      else seg_idx = (seg_idx << 1) | 1 , left = mid; ",
      "    }",
      "    return ret;",
      "  }",
      " ",
      "  void merge(DynamicLiChaoTree<T,INF> &other){",
      "    if(seg.size() < other.seg.size()) seg.swap(other.seg);",
      "    for(auto &x : other.seg){",
      "      if(x.second.intercept == INF) continue;",
      "      update(x.second.slope , x.second.intercept , x.first);",
      "    }",
      "  }",
      " ",
      "};"
    ],
    "description": "Dynamic_Li_Chao_Tree"
  },
  "Geometry": {
    "prefix": "_geometry",
    "body": [
      "",
      "using Real = long double;",
      "using Point = complex< Real >;",
      "using Points = vector< Point >;",
      "constexpr Real EPS = 1e-8; // 問題によって変える！",
      "constexpr Real pi = 3.141592653589793238462643383279L;",
      "istream &operator>>(istream &is, Point &p) {",
      "  Real a, b;",
      "  is >> a >> b;",
      "  p = Point(a, b);",
      "  return is;",
      "}",
      "ostream &operator<<(ostream &os, Point &p) {",
      "  return os << real(p) << \" \" << imag(p);",
      "}",
      "inline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }",
      " ",
      "Point operator*(const Point &p, const Real &d) {",
      "  return Point(real(p) * d, imag(p) * d);",
      "}",
      " ",
      "namespace std {",
      "  bool operator<(const Point &a, const Point &b) {",
      "    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();",
      "  }",
      "}",
      "",
      "Real cross(const Point &a, const Point &b) {",
      "  return real(a) * imag(b) - imag(a) * real(b);",
      "}",
      "Real dot(const Point &a, const Point &b) {",
      "  return real(a) * real(b) + imag(a) * imag(b);",
      "}",
      " ",
      "// ccw 点の進行方向",
      "int ccw(const Point &a, Point b, Point c) {",
      "  b = b - a, c = c - a;",
      "  if(cross(b, c) > EPS) return +1;  // 反時計回り",
      "  if(cross(b, c) < -EPS) return -1; // 時計回り",
      "  if(dot(b, c) < 0) return +2;      // c-a-bの順で一直線",
      "  if(norm(b) < norm(c)) return -2;  // a-b-cの順で一直線",
      "  return 0;                         // a-c-bの順で一直線",
      "}",
      "",
      "// a-bベクトルとb-cベクトルのなす角度のうち小さい方を返す",
      "// (ベクトル同士のなす角、すなわち幾何でいうところの「外角」であることに注意！)",
      "// rem. 凸包に対して反時計回りにこの関数を適用すると、",
      "// 凸包の大きさにかかわらず和が360度になる(いわゆる外角の和)(AGC021-B)",
      "Real get_angle(const Point &a, const Point &b, const Point &c) {",
      "  const Point v(b - a), w(c - b);",
      "  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());",
      "  if(alpha > beta) swap(alpha, beta);",
      "  Real theta = (beta - alpha);",
      "  return min(theta, 2 * acos(-1) - theta);",
      "}",
      "",
      "//　反時計回りである自己交差のない多角形のclass",
      "using Polygon = vector<Point>;",
      " ",
      "// 凸包",
      "Polygon convex_hull(vector<Point> ps){",
      "int n = (int) ps.size(), k = 0;",
      "  if(n <= 2) return ps;",
      "  sort(ps.begin(), ps.end());",
      "  vector< Point > ch(2 * n);",
      "  // 反時計周りに凸包を構築していく",
      "  for(int i = 0; i < n; ch[k++] = ps[i++]) {",
      "    // 条件分岐内はwhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) != 1)と等価",
      "    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], ps[i] - ch[k - 1]) < EPS) --k;",
      "  }",
      "  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--]) {",
      "    while(k >= t && cross(ch[k - 1] - ch[k - 2], ps[i] - ch[k - 1]) < EPS) --k;",
      "  }",
      "  ch.resize(k - 1);",
      "  return ch;",
      "}",
      " ",
      "// 多角形の面積",
      "Real area(const Polygon &p) {",
      "  Real A = 0;",
      "  for(int i = 0; i < (int)p.size(); ++i) {",
      "    A += cross(p[i], p[(i + 1) % p.size()]);",
      "  }",
      "  return A * 0.5;",
      "}",
      "",
      "struct Circle {",
      "  Point p;",
      "  Real r;",
      "",
      "  Circle() = default;",
      "  Circle(Point p, Real r) : p(p), r(r) {}",
      "};",
      "",
      "using Circles = vector< Circle >;",
      "",
      "int intersect(Circle c1, Circle c2) {",
      "  if(c1.r < c2.r) swap(c1, c2);",
      "  Real d = abs(c1.p - c2.p);",
      "  if(c1.r + c2.r < d) return 4;",
      "  if(eq(c1.r + c2.r, d)) return 3;",
      "  if(c1.r - c2.r < d) return 2;",
      "  if(eq(c1.r - c2.r, d)) return 1;",
      "  return 0;",
      "}",
      "",
      "pair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {",
      "  Real d = abs(c1.p - c2.p);",
      "  Real x = (c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d);",
      "  if(abs(x) > 1) x = (x > 0 ? 1.0 : -1.0);",
      "  Real a = acos(x);",
      "  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());",
      "  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);",
      "  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);",
      "  return {p1, p2};",
      "}",
      ""
    ],
    "description": "geometry"
  },
  "Formal_Power_Series": {
    "prefix": "_FormalPowerSeries",
    "body": [
      "template <uint32_t mod>",
      "struct LazyMontgomeryModInt {",
      "  using mint = LazyMontgomeryModInt;",
      "  using i32 = int32_t;",
      "  using u32 = uint32_t;",
      "  using u64 = uint64_t;",
      "",
      "  static constexpr u32 get_r() {",
      "    u32 ret = mod;",
      "    for (i32 i = 0; i < 4; ++i) ret *= 2 - mod * ret;",
      "    return -ret;",
      "  }",
      "",
      "  static constexpr u32 r = get_r();",
      "  static constexpr u32 n2 = -u64(mod) % mod;",
      "  static_assert(-r * mod == 1, \"invalid, r * mod != 1\");",
      "  static_assert(mod < (1 << 30), \"invalid, mod >= 2 ^ 30\");",
      "  static_assert((mod & 1) == 1, \"invalid, mod % 2 == 0\");",
      "",
      "  u32 a;",
      "",
      "  constexpr LazyMontgomeryModInt() : a(0) {}",
      "  constexpr LazyMontgomeryModInt(const int64_t &b)",
      "      : a(reduce(u64(b % mod + mod) * n2)){};",
      "",
      "  static constexpr u32 reduce(const u64 &b) {",
      "    return (b + u64(u32(b) * r) * mod) >> 32;",
      "  }",
      "",
      "  constexpr mint &operator+=(const mint &b) {",
      "    if (i32(a += b.a - 2 * mod) < 0) a += 2 * mod;",
      "    return *this;",
      "  }",
      "",
      "  constexpr mint &operator-=(const mint &b) {",
      "    if (i32(a -= b.a) < 0) a += 2 * mod;",
      "    return *this;",
      "  }",
      "",
      "  constexpr mint &operator*=(const mint &b) {",
      "    a = reduce(u64(a) * b.a);",
      "    return *this;",
      "  }",
      "",
      "  constexpr mint &operator/=(const mint &b) {",
      "    *this *= b.inverse();",
      "    return *this;",
      "  }",
      "",
      "  constexpr mint operator+(const mint &b) const { return mint(*this) += b; }",
      "  constexpr mint operator-(const mint &b) const { return mint(*this) -= b; }",
      "  constexpr mint operator*(const mint &b) const { return mint(*this) *= b; }",
      "  constexpr mint operator/(const mint &b) const { return mint(*this) /= b; }",
      "  constexpr bool operator==(const mint &b) const {",
      "    return (a >= mod ? a - mod : a) == (b.a >= mod ? b.a - mod : b.a);",
      "  }",
      "  constexpr bool operator!=(const mint &b) const {",
      "    return (a >= mod ? a - mod : a) != (b.a >= mod ? b.a - mod : b.a);",
      "  }",
      "  constexpr mint operator-() const { return mint() - mint(*this); }",
      "",
      "  constexpr u32 get() const {",
      "    u32 ret = reduce(a);",
      "    return ret >= mod ? ret - mod : ret;",
      "  }",
      "",
      "  constexpr mint pow(u64 n) const {",
      "    mint ret(1), mul(*this);",
      "    while (n > 0) {",
      "      if (n & 1) ret *= mul;",
      "      mul *= mul;",
      "      n >>= 1;",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  friend ostream &operator<<(ostream &os, const mint &b) {",
      "    return os << b.get();",
      "  }",
      "",
      "  friend istream &operator>>(istream &is, mint &b) {",
      "    int64_t t;",
      "    is >> t;",
      "    b = LazyMontgomeryModInt<mod>(t);",
      "    return (is);",
      "  }",
      "",
      "  constexpr mint inverse() const { return pow(mod - 2); }",
      "",
      "  static constexpr u32 get_mod() { return mod; }",
      "};",
      "",
      "struct ArbitraryModInt {",
      "  int x;",
      "",
      "  ArbitraryModInt() : x(0) {}",
      "",
      "  ArbitraryModInt(int64_t y)",
      "      : x(y >= 0 ? y % get_mod() : (get_mod() - (-y) % get_mod()) % get_mod()) {",
      "  }",
      "",
      "  static int &get_mod() {",
      "    static int mod = 0;",
      "    return mod;",
      "  }",
      "",
      "  static void set_mod(int md) { get_mod() = md; }",
      "",
      "  ArbitraryModInt &operator+=(const ArbitraryModInt &p) {",
      "    if ((x += p.x) >= get_mod()) x -= get_mod();",
      "    return *this;",
      "  }",
      "",
      "  ArbitraryModInt &operator-=(const ArbitraryModInt &p) {",
      "    if ((x += get_mod() - p.x) >= get_mod()) x -= get_mod();",
      "    return *this;",
      "  }",
      "",
      "  ArbitraryModInt &operator*=(const ArbitraryModInt &p) {",
      "    unsigned long long a = (unsigned long long)x * p.x;",
      "    unsigned xh = (unsigned)(a >> 32), xl = (unsigned)a, d, m;",
      "    asm(\"divl %4; \\n\\t\" : \"=a\"(d), \"=d\"(m) : \"d\"(xh), \"a\"(xl), \"r\"(get_mod()));",
      "    x = m;",
      "    return *this;",
      "  }",
      "",
      "  ArbitraryModInt &operator/=(const ArbitraryModInt &p) {",
      "    *this *= p.inverse();",
      "    return *this;",
      "  }",
      "",
      "  ArbitraryModInt operator-() const { return ArbitraryModInt(-x); }",
      "",
      "  ArbitraryModInt operator+(const ArbitraryModInt &p) const {",
      "    return ArbitraryModInt(*this) += p;",
      "  }",
      "",
      "  ArbitraryModInt operator-(const ArbitraryModInt &p) const {",
      "    return ArbitraryModInt(*this) -= p;",
      "  }",
      "",
      "  ArbitraryModInt operator*(const ArbitraryModInt &p) const {",
      "    return ArbitraryModInt(*this) *= p;",
      "  }",
      "",
      "  ArbitraryModInt operator/(const ArbitraryModInt &p) const {",
      "    return ArbitraryModInt(*this) /= p;",
      "  }",
      "",
      "  bool operator==(const ArbitraryModInt &p) const { return x == p.x; }",
      "",
      "  bool operator!=(const ArbitraryModInt &p) const { return x != p.x; }",
      "",
      "  int get() const { return x; }",
      "",
      "  ArbitraryModInt inverse() const {",
      "    int a = x, b = get_mod(), u = 1, v = 0, t;",
      "    while (b > 0) {",
      "      t = a / b;",
      "      swap(a -= t * b, b);",
      "      swap(u -= t * v, v);",
      "    }",
      "    return ArbitraryModInt(u);",
      "  }",
      "",
      "  ArbitraryModInt pow(int64_t n) const {",
      "    ArbitraryModInt ret(1), mul(x);",
      "    while (n > 0) {",
      "      if (n & 1) ret *= mul;",
      "      mul *= mul;",
      "      n >>= 1;",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  friend ostream &operator<<(ostream &os, const ArbitraryModInt &p) {",
      "    return os << p.x;",
      "  }",
      "",
      "  friend istream &operator>>(istream &is, ArbitraryModInt &a) {",
      "    int64_t t;",
      "    is >> t;",
      "    a = ArbitraryModInt(t);",
      "    return (is);",
      "  }",
      "};",
      "",
      "static constexpr uint32_t get_pr(uint32_t mod) {",
      "  using u64 = uint64_t;",
      "  u64 ds[32] = {};",
      "  int idx = 0;",
      "  u64 m = mod - 1;",
      "  for (u64 i = 2; i * i <= m; ++i) {",
      "    if (m % i == 0) {",
      "      ds[idx++] = i;",
      "      while (m % i == 0) m /= i;",
      "    }",
      "  }",
      "  if (m != 1) ds[idx++] = m;",
      "",
      "  uint32_t pr = 2;",
      "  while (1) {",
      "    int flg = 1;",
      "    for (int i = 0; i < idx; ++i) {",
      "      u64 a = pr, b = (mod - 1) / ds[i], r = 1;",
      "      while (b) {",
      "        if (b & 1) r = r * a % mod;",
      "        a = a * a % mod;",
      "        b >>= 1;",
      "      }",
      "      if (r == 1) {",
      "        flg = 0;",
      "        break;",
      "      }",
      "    }",
      "    if (flg == 1) break;",
      "    ++pr;",
      "  }",
      "  return pr;",
      "};",
      "",
      "template <typename mint>",
      "struct NTT {",
      "  static constexpr uint32_t mod = mint::get_mod();",
      "  static constexpr uint32_t pr = get_pr(mod);",
      "  static constexpr int level = __builtin_ctzll(mod - 1);",
      "  mint dw[level], dy[level];",
      "",
      "  NTT() { setwy(level); }",
      "",
      "  constexpr void setwy(int k) {",
      "    mint w[level], y[level];",
      "    w[k - 1] = mint(pr).pow((mod - 1) / (1 << k));",
      "    y[k - 1] = w[k - 1].inverse();",
      "    for (int i = k - 2; i > 0; --i)",
      "      w[i] = w[i + 1] * w[i + 1], y[i] = y[i + 1] * y[i + 1];",
      "    dw[1] = w[1], dy[1] = y[1], dw[2] = w[2], dy[2] = y[2];",
      "    for (int i = 3; i < k; ++i) {",
      "      dw[i] = dw[i - 1] * y[i - 2] * w[i];",
      "      dy[i] = dy[i - 1] * w[i - 2] * y[i];",
      "    }",
      "  }",
      "",
      "  constexpr void ntt(vector<mint> &a, int n = -1) {",
      "    if (n == -1) n = a.size();",
      "    int k = n ? __builtin_ctz(n) : 0;",
      "    if (k == 0) return;",
      "    if (k == 1) {",
      "      mint a1 = a[1];",
      "      a[1] = a[0] - a[1];",
      "      a[0] = a[0] + a1;",
      "      return;",
      "    }",
      "    if (k & 1) {",
      "      int v = 1 << (k - 1);",
      "      for (int j = 0; j < v; ++j) {",
      "        mint ajv = a[j + v];",
      "        a[j + v] = a[j] - ajv;",
      "        a[j] += ajv;",
      "      }",
      "    }",
      "    int u = 1 << (2 + (k & 1));",
      "    int v = 1 << (k - 2 - (k & 1));",
      "    mint one = mint(1);",
      "    mint imag = dw[1];",
      "    while (v) {",
      "      // jh = 0",
      "      {",
      "        int j0 = 0;",
      "        int j1 = v;",
      "        int j2 = j1 + v;",
      "        int j3 = j2 + v;",
      "        for (; j0 < v; ++j0, ++j1, ++j2, ++j3) {",
      "          mint t0 = a[j0], t1 = a[j1], t2 = a[j2], t3 = a[j3];",
      "          mint t0p2 = t0 + t2, t1p3 = t1 + t3;",
      "          mint t0m2 = t0 - t2, t1m3 = (t1 - t3) * imag;",
      "          a[j0] = t0p2 + t1p3, a[j1] = t0p2 - t1p3;",
      "          a[j2] = t0m2 + t1m3, a[j3] = t0m2 - t1m3;",
      "        }",
      "      }",
      "      // jh >= 1",
      "      mint ww = one, xx = one * dw[2], wx = one;",
      "      for (int jh = 4; jh < u;) {",
      "        ww = xx * xx, wx = ww * xx;",
      "        int j0 = jh * v;",
      "        int je = j0 + v;",
      "        int j2 = je + v;",
      "        for (; j0 < je; ++j0, ++j2) {",
      "          mint t0 = a[j0], t1 = a[j0 + v] * xx, t2 = a[j2] * ww,",
      "               t3 = a[j2 + v] * wx;",
      "          mint t0p2 = t0 + t2, t1p3 = t1 + t3;",
      "          mint t0m2 = t0 - t2, t1m3 = (t1 - t3) * imag;",
      "          a[j0] = t0p2 + t1p3, a[j0 + v] = t0p2 - t1p3;",
      "          a[j2] = t0m2 + t1m3, a[j2 + v] = t0m2 - t1m3;",
      "        }",
      "        xx *= dw[__builtin_ctzll((jh += 4))];",
      "      }",
      "      u <<= 2;",
      "      v >>= 2;",
      "    }",
      "  }",
      "",
      "  constexpr void intt(vector<mint> &a, int n = -1, int normalize = true) {",
      "    if (n == -1) n = a.size();",
      "    int k = n ? __builtin_ctz(n) : 0;",
      "    if (k == 0) return;",
      "    if (k == 1) {",
      "      mint a1 = a[1];",
      "      a[1] = a[0] - a[1];",
      "      a[0] = a[0] + a1;",
      "      return;",
      "    }",
      "    int u = 1 << (k - 2);",
      "    int v = 1;",
      "    mint one = mint(1);",
      "    mint imag = dy[1];",
      "    while (u) {",
      "      // jh = 0",
      "      {",
      "        int j0 = 0;",
      "        int j1 = v;",
      "        int j2 = v + v;",
      "        int j3 = j2 + v;",
      "        for (; j0 < v; ++j0, ++j1, ++j2, ++j3) {",
      "          mint t0 = a[j0], t1 = a[j1], t2 = a[j2], t3 = a[j3];",
      "          mint t0p1 = t0 + t1, t2p3 = t2 + t3;",
      "          mint t0m1 = t0 - t1, t2m3 = (t2 - t3) * imag;",
      "          a[j0] = t0p1 + t2p3, a[j2] = t0p1 - t2p3;",
      "          a[j1] = t0m1 + t2m3, a[j3] = t0m1 - t2m3;",
      "        }",
      "      }",
      "      // jh >= 1",
      "      mint ww = one, xx = one * dy[2], yy = one;",
      "      u <<= 2;",
      "      for (int jh = 4; jh < u;) {",
      "        ww = xx * xx, yy = xx * imag;",
      "        int j0 = jh * v;",
      "        int je = j0 + v;",
      "        int j2 = je + v;",
      "        for (; j0 < je; ++j0, ++j2) {",
      "          mint t0 = a[j0], t1 = a[j0 + v], t2 = a[j2], t3 = a[j2 + v];",
      "          mint t0p1 = t0 + t1, t2p3 = t2 + t3;",
      "          mint t0m1 = (t0 - t1) * xx, t2m3 = (t2 - t3) * yy;",
      "          a[j0] = t0p1 + t2p3, a[j2] = (t0p1 - t2p3) * ww;",
      "          a[j0 + v] = t0m1 + t2m3, a[j2 + v] = (t0m1 - t2m3) * ww;",
      "        }",
      "        xx *= dy[__builtin_ctzll(jh += 4)];",
      "      }",
      "      u >>= 4;",
      "      v <<= 2;",
      "    }",
      "    if (k & 1) {",
      "      u = 1 << (k - 1);",
      "      for (int j = 0; j < u; ++j) {",
      "        mint ajv = a[j] - a[j + u];",
      "        a[j] += a[j + u];",
      "        a[j + u] = ajv;",
      "      }",
      "    }",
      "    if (normalize) {",
      "      mint invn = mint(1) / mint(n);",
      "      for (int i = 0; i < n; i++) a[i] *= invn;",
      "    }",
      "  }",
      "",
      "  constexpr vector<mint> multiply(const vector<mint> &a,",
      "                                  const vector<mint> &b) {",
      "    int l = a.size() + b.size() - 1;",
      "    if (min<int>(a.size(), b.size()) <= 40) {",
      "      vector<mint> s(l);",
      "      for (int i = 0; i < (int)a.size(); ++i)",
      "        for (int j = 0; j < (int)b.size(); ++j) s[i + j] += a[i] * b[j];",
      "      return s;",
      "    }",
      "    int M = 4;",
      "    while (M < l) M <<= 1;",
      "    vector<mint> s(M), t(M);",
      "    for (int i = 0; i < (int)a.size(); ++i) s[i] = a[i];",
      "    for (int i = 0; i < (int)b.size(); ++i) t[i] = b[i];",
      "    ntt(s, M);",
      "    ntt(t, M);",
      "    for (int i = 0; i < M; ++i) s[i] *= t[i];",
      "    intt(s, M, false);",
      "    s.resize(l);",
      "    mint invm = mint(M).inverse();",
      "    for (int i = 0; i < l; ++i) s[i] *= invm;",
      "    return s;",
      "  }",
      "};",
      "",
      "namespace ArbitraryNTT {",
      "constexpr int32_t m0 = 167772161;",
      "constexpr int32_t m1 = 469762049;",
      "constexpr int32_t m2 = 754974721;",
      "using mint0 = LazyMontgomeryModInt<m0>;",
      "using mint1 = LazyMontgomeryModInt<m1>;",
      "using mint2 = LazyMontgomeryModInt<m2>;",
      "",
      "template <int mod>",
      "vector<LazyMontgomeryModInt<mod>> mul(const vector<int> &a,",
      "                                      const vector<int> &b) {",
      "  using submint = LazyMontgomeryModInt<mod>;",
      "  NTT<submint> ntt;",
      "  vector<submint> s(a.size()), t(b.size());",
      "  for (int i = 0; i < (int)a.size(); ++i) s[i] = a[i];",
      "  for (int i = 0; i < (int)b.size(); ++i) t[i] = b[i];",
      "  return std::move(ntt.multiply(s, t));",
      "}",
      "",
      "template <int mod>",
      "vector<int> multiply(const vector<int> &s, const vector<int> &t) {",
      "  auto d0 = mul<m0>(s, t);",
      "  auto d1 = mul<m1>(s, t);",
      "  auto d2 = mul<m2>(s, t);",
      "  int n = d0.size();",
      "  vector<int> res(n);",
      "  using i64 = int64_t;",
      "  static const int r01 = mint1(m0).inverse().get();",
      "  static const int r02 = mint2(m0).inverse().get();",
      "  static const int r12 = mint2(m1).inverse().get();",
      "  static const int r02r12 = i64(r02) * r12 % m2;",
      "  static const int w1 = m0 % mod;",
      "  static const int w2 = i64(w1) * m1 % mod;",
      "  for (int i = 0; i < n; i++) {",
      "    i64 n1 = d1[i].get(), n2 = d2[i].get();",
      "    i64 a = d0[i].get();",
      "    i64 b = (n1 + m1 - a) * r01 % m1;",
      "    i64 c = ((n2 + m2 - a) * r02r12 + (m2 - b) * r12) % m2;",
      "    res[i] = (a + b * w1 + c * w2) % mod;",
      "  }",
      "  return std::move(res);",
      "}",
      "",
      "vector<int> multiply(const vector<int> &s, const vector<int> &t, int mod) {",
      "  auto d0 = mul<m0>(s, t);",
      "  auto d1 = mul<m1>(s, t);",
      "  auto d2 = mul<m2>(s, t);",
      "  int n = d0.size();",
      "  vector<int> res(n);",
      "  using i64 = int64_t;",
      "  static const int r01 = mint1(m0).inverse().get();",
      "  static const int r02 = mint2(m0).inverse().get();",
      "  static const int r12 = mint2(m1).inverse().get();",
      "  static const int r02r12 = i64(r02) * r12 % m2;",
      "  static const int w1 = m0 % mod;",
      "  static const int w2 = i64(w1) * m1 % mod;",
      "  for (int i = 0; i < n; i++) {",
      "    i64 n1 = d1[i].get(), n2 = d2[i].get();",
      "    i64 a = d0[i].get();",
      "    i64 b = (n1 + m1 - a) * r01 % m1;",
      "    i64 c = ((n2 + m2 - a) * r02r12 + (m2 - b) * r12) % m2;",
      "    res[i] = (a + b * w1 + c * w2) % mod;",
      "  }",
      "  return std::move(res);",
      "}",
      "",
      "template <int mod>",
      "vector<LazyMontgomeryModInt<mod>> multiply(",
      "    const vector<LazyMontgomeryModInt<mod>> &a,",
      "    const vector<LazyMontgomeryModInt<mod>> &b) {",
      "  using mint = LazyMontgomeryModInt<mod>;",
      "  vector<int> s(a.size()), t(b.size());",
      "  for (int i = 0; i < (int)a.size(); ++i) s[i] = a[i].get();",
      "  for (int i = 0; i < (int)b.size(); ++i) t[i] = b[i].get();",
      "  vector<int> u = multiply<mod>(s, t);",
      "  vector<mint> ret(u.size());",
      "  for (int i = 0; i < (int)u.size(); ++i)",
      "    ret[i].a = mint::reduce(uint64_t(u[i]) * mint::n2);",
      "  return std::move(ret);",
      "}",
      "",
      "vector<ArbitraryModInt> multiply(const vector<ArbitraryModInt> &a,",
      "                                 const vector<ArbitraryModInt> &b) {",
      "  using mint = ArbitraryModInt;",
      "  vector<int> s(a.size()), t(b.size());",
      "  for (int i = 0; i < (int)a.size(); ++i) s[i] = a[i].x;",
      "  for (int i = 0; i < (int)b.size(); ++i) t[i] = b[i].x;",
      "  vector<int> u = multiply(s, t, ArbitraryModInt::get_mod());",
      "  vector<mint> ret(u.size());",
      "  for (int i = 0; i < (int)u.size(); ++i) ret[i].x = u[i];",
      "  return std::move(ret);",
      "}",
      "}  // namespace ArbitraryNTT",
      "",
      "template <typename T>",
      "struct FormalPowerSeries : vector<T> {",
      "  using vector<T>::vector;",
      "  using P = FormalPowerSeries;",
      "",
      "  using MULT = function<P(P, P)>;",
      "  using FFT = function<void(P &)>;",
      "  using SQRT = function<T(T)>;",
      "",
      "  static MULT &get_mult() {",
      "    static MULT mult = nullptr;",
      "    return mult;",
      "  }",
      "",
      "  static void set_mult(MULT f) { get_mult() = f; }",
      "",
      "  static FFT &get_fft() {",
      "    static FFT fft = nullptr;",
      "    return fft;",
      "  }",
      "",
      "  static FFT &get_ifft() {",
      "    static FFT ifft = nullptr;",
      "    return ifft;",
      "  }",
      "",
      "  static void set_fft(FFT f, FFT g) {",
      "    get_fft() = f;",
      "    get_ifft() = g;",
      "  }",
      "",
      "  static SQRT &get_sqrt() {",
      "    static SQRT sqr = nullptr;",
      "    return sqr;",
      "  }",
      "",
      "  static void set_sqrt(SQRT sqr) { get_sqrt() = sqr; }",
      "",
      "  void shrink() {",
      "    while (this->size() && this->back() == T(0)) this->pop_back();",
      "  }",
      "",
      "  P operator+(const P &r) const { return P(*this) += r; }",
      "",
      "  P operator+(const T &v) const { return P(*this) += v; }",
      "",
      "  P operator-(const P &r) const { return P(*this) -= r; }",
      "",
      "  P operator-(const T &v) const { return P(*this) -= v; }",
      "",
      "  P operator*(const P &r) const { return P(*this) *= r; }",
      "",
      "  P operator*(const T &v) const { return P(*this) *= v; }",
      "",
      "  P operator/(const P &r) const { return P(*this) /= r; }",
      "",
      "  P operator%(const P &r) const { return P(*this) %= r; }",
      "",
      "  P &operator+=(const P &r) {",
      "    if (r.size() > this->size()) this->resize(r.size());",
      "    for (int i = 0; i < r.size(); i++) (*this)[i] += r[i];",
      "    return *this;",
      "  }",
      "",
      "  P &operator+=(const T &r) {",
      "    if (this->empty()) this->resize(1);",
      "    (*this)[0] += r;",
      "    return *this;",
      "  }",
      "",
      "  P &operator-=(const P &r) {",
      "    if (r.size() > this->size()) this->resize(r.size());",
      "    for (int i = 0; i < r.size(); i++) (*this)[i] -= r[i];",
      "    shrink();",
      "    return *this;",
      "  }",
      "",
      "  P &operator-=(const T &r) {",
      "    if (this->empty()) this->resize(1);",
      "    (*this)[0] -= r;",
      "    shrink();",
      "    return *this;",
      "  }",
      "",
      "  P &operator*=(const T &v) {",
      "    const int n = (int)this->size();",
      "    for (int k = 0; k < n; k++) (*this)[k] *= v;",
      "    return *this;",
      "  }",
      "",
      "  P &operator*=(const P &r) {",
      "    if (this->empty() || r.empty()) {",
      "      this->clear();",
      "      return *this;",
      "    }",
      "    assert(get_mult() != nullptr);",
      "    return *this = get_mult()(*this, r);",
      "  }",
      "",
      "  P &operator%=(const P &r) { return *this -= *this / r * r; }",
      "",
      "  P operator-() const {",
      "    P ret(this->size());",
      "    for (int i = 0; i < this->size(); i++) ret[i] = -(*this)[i];",
      "    return ret;",
      "  }",
      "",
      "  P &operator/=(const P &r) {",
      "    if (this->size() < r.size()) {",
      "      this->clear();",
      "      return *this;",
      "    }",
      "    int n = this->size() - r.size() + 1;",
      "    return *this = (rev().pre(n) * r.rev().inv(n)).pre(n).rev(n);",
      "  }",
      "",
      "  P dot(P r) const {",
      "    P ret(min(this->size(), r.size()));",
      "    for (int i = 0; i < ret.size(); i++) ret[i] = (*this)[i] * r[i];",
      "    return ret;",
      "  }",
      "",
      "  P pre(int sz) const {",
      "    return P(begin(*this), begin(*this) + min((int)this->size(), sz));",
      "  }",
      "",
      "  P operator>>(int sz) const {",
      "    if (this->size() <= sz) return {};",
      "    P ret(*this);",
      "    ret.erase(ret.begin(), ret.begin() + sz);",
      "    return ret;",
      "  }",
      "",
      "  P operator<<(int sz) const {",
      "    P ret(*this);",
      "    ret.insert(ret.begin(), sz, T(0));",
      "    return ret;",
      "  }",
      "",
      "  P rev(int deg = -1) const {",
      "    P ret(*this);",
      "    if (deg != -1) ret.resize(deg, T(0));",
      "    reverse(begin(ret), end(ret));",
      "    return ret;",
      "  }",
      "",
      "  P diff() const {",
      "    const int n = (int)this->size();",
      "    P ret(max(0, n - 1));",
      "    for (int i = 1; i < n; i++) ret[i - 1] = (*this)[i] * T(i);",
      "    return ret;",
      "  }",
      "",
      "  P integral() const {",
      "    const int n = (int)this->size();",
      "    P ret(n + 1);",
      "    ret[0] = T(0);",
      "    for (int i = 0; i < n; i++) ret[i + 1] = (*this)[i] / T(i + 1);",
      "    return ret;",
      "  }",
      "",
      "  // F(0) must not be 0",
      "  P inv(int deg = -1) const {",
      "    assert(((*this)[0]) != T(0));",
      "    const int n = (int)this->size();",
      "    if (deg == -1) deg = n;",
      "    if (get_fft() != nullptr) {",
      "      P ret(*this);",
      "      ret.resize(deg, T(0));",
      "      return ret.inv_fast();",
      "    }",
      "    P ret({T(1) / (*this)[0]});",
      "    for (int i = 1; i < deg; i <<= 1) {",
      "      ret = (ret + ret - ret * ret * pre(i << 1)).pre(i << 1);",
      "    }",
      "    return ret.pre(deg);",
      "  }",
      "",
      "  // F(0) must be 1",
      "  P log(int deg = -1) const {",
      "    assert((*this)[0] == 1);",
      "    const int n = (int)this->size();",
      "    if (deg == -1) deg = n;",
      "    return (this->diff() * this->inv(deg)).pre(deg - 1).integral();",
      "  }",
      "",
      "  P sqrt(int deg = -1) const {",
      "    const int n = (int)this->size();",
      "    if (deg == -1) deg = n;",
      "    if ((*this)[0] == T(0)) {",
      "      for (int i = 1; i < n; i++) {",
      "        if ((*this)[i] != T(0)) {",
      "          if (i & 1) return {};",
      "          if (deg - i / 2 <= 0) break;",
      "          auto ret = (*this >> i).sqrt(deg - i / 2);",
      "          if (ret.empty()) return {};",
      "          ret = ret << (i / 2);",
      "          if (ret.size() < deg) ret.resize(deg, T(0));",
      "          return ret;",
      "        }",
      "      }",
      "      return P(deg, 0);",
      "    }",
      "",
      "    P ret;",
      "    if (get_sqrt() == nullptr) {",
      "      assert((*this)[0] == T(1));",
      "      ret = {T(1)};",
      "    } else {",
      "      auto sqr = get_sqrt()((*this)[0]);",
      "      if (sqr * sqr != (*this)[0]) return {};",
      "      ret = {T(sqr)};",
      "    }",
      "",
      "    T inv2 = T(1) / T(2);",
      "    for (int i = 1; i < deg; i <<= 1) {",
      "      ret = (ret + pre(i << 1) * ret.inv(i << 1)) * inv2;",
      "    }",
      "    return ret.pre(deg);",
      "  }",
      "",
      "  // F(0) must be 0",
      "  P exp(int deg = -1) const {",
      "    assert((*this)[0] == T(0));",
      "    const int n = (int)this->size();",
      "    if (deg == -1) deg = n;",
      "    if (get_fft() != nullptr) {",
      "      P ret(*this);",
      "      ret.resize(deg, T(0));",
      "      return ret.exp_rec();",
      "    }",
      "    P ret({T(1)});",
      "    for (int i = 1; i < deg; i <<= 1) {",
      "      ret = (ret * (pre(i << 1) + T(1) - ret.log(i << 1))).pre(i << 1);",
      "    }",
      "    return ret.pre(deg);",
      "  }",
      "",
      "  P online_convolution_exp(const P &conv_coeff) const {",
      "    const int n = (int)conv_coeff.size();",
      "    assert((n & (n - 1)) == 0);",
      "    vector<P> conv_ntt_coeff;",
      "    auto &fft = get_fft();",
      "    auto &ifft = get_ifft();",
      "    for (int i = n; i >= 1; i >>= 1) {",
      "      P g(conv_coeff.pre(i));",
      "      fft(g);",
      "      conv_ntt_coeff.emplace_back(g);",
      "    }",
      "    P conv_arg(n), conv_ret(n);",
      "    auto rec = [&](auto rec, int l, int r, int d) -> void {",
      "      if (r - l <= 16) {",
      "        for (int i = l; i < r; i++) {",
      "          T sum = 0;",
      "          for (int j = l; j < i; j++) sum += conv_arg[j] * conv_coeff[i - j];",
      "          conv_ret[i] += sum;",
      "          conv_arg[i] = i == 0 ? T(1) : conv_ret[i] / i;",
      "        }",
      "      } else {",
      "        int m = (l + r) / 2;",
      "        rec(rec, l, m, d + 1);",
      "        P pre(r - l);",
      "        for (int i = 0; i < m - l; i++) pre[i] = conv_arg[l + i];",
      "        fft(pre);",
      "        for (int i = 0; i < r - l; i++) pre[i] *= conv_ntt_coeff[d][i];",
      "        ifft(pre);",
      "        for (int i = 0; i < r - m; i++) conv_ret[m + i] += pre[m + i - l];",
      "        rec(rec, m, r, d + 1);",
      "      }",
      "    };",
      "    rec(rec, 0, n, 0);",
      "    return conv_arg;",
      "  }",
      "",
      "  P exp_rec() const {",
      "    assert((*this)[0] == T(0));",
      "    const int n = (int)this->size();",
      "    int m = 1;",
      "    while (m < n) m *= 2;",
      "    P conv_coeff(m);",
      "    for (int i = 1; i < n; i++) conv_coeff[i] = (*this)[i] * i;",
      "    return online_convolution_exp(conv_coeff).pre(n);",
      "  }",
      "",
      "  P inv_fast() const {",
      "    assert(((*this)[0]) != T(0));",
      "",
      "    const int n = (int)this->size();",
      "    P res{T(1) / (*this)[0]};",
      "",
      "    for (int d = 1; d < n; d <<= 1) {",
      "      P f(2 * d), g(2 * d);",
      "      for (int j = 0; j < min(n, 2 * d); j++) f[j] = (*this)[j];",
      "      for (int j = 0; j < d; j++) g[j] = res[j];",
      "      get_fft()(f);",
      "      get_fft()(g);",
      "      for (int j = 0; j < 2 * d; j++) f[j] *= g[j];",
      "      get_ifft()(f);",
      "      for (int j = 0; j < d; j++) {",
      "        f[j] = 0;",
      "        f[j + d] = -f[j + d];",
      "      }",
      "      get_fft()(f);",
      "      for (int j = 0; j < 2 * d; j++) f[j] *= g[j];",
      "      get_ifft()(f);",
      "      for (int j = 0; j < d; j++) f[j] = res[j];",
      "      res = f;",
      "    }",
      "    return res.pre(n);",
      "  }",
      "",
      "  P pow(int64_t k, int deg = -1) const {",
      "    const int n = (int)this->size();",
      "    if (deg == -1) deg = n;",
      "    for (int i = 0; i < n; i++) {",
      "      if ((*this)[i] != T(0)) {",
      "        T rev = T(1) / (*this)[i];",
      "        P ret = (((*this * rev) >> i).log() * k).exp() * ((*this)[i].pow(k));",
      "        if (i * k > deg) return P(deg, T(0));",
      "        ret = (ret << (i * k)).pre(deg);",
      "        if (ret.size() < deg) ret.resize(deg, T(0));",
      "        return ret;",
      "      }",
      "    }",
      "    return *this;",
      "  }",
      "",
      "  T eval(T x) const {",
      "    T r = 0, w = 1;",
      "    for (auto &v : *this) {",
      "      r += w * v;",
      "      w *= x;",
      "    }",
      "    return r;",
      "  }",
      "",
      "  P pow_mod(int64_t n, P mod) const {",
      "    P modinv = mod.rev().inv();",
      "    auto get_div = [&](P base) {",
      "      if (base.size() < mod.size()) {",
      "        base.clear();",
      "        return base;",
      "      }",
      "      int n = base.size() - mod.size() + 1;",
      "      return (base.rev().pre(n) * modinv.pre(n)).pre(n).rev(n);",
      "    };",
      "    P x(*this), ret{1};",
      "    while (n > 0) {",
      "      if (n & 1) {",
      "        ret *= x;",
      "        ret -= get_div(ret) * mod;",
      "      }",
      "      x *= x;",
      "      x -= get_div(x) * mod;",
      "      n >>= 1;",
      "    }",
      "    return ret;",
      "  }",
      "};",
      "",
      "// if mod is constant FFT mod",
      "/**",
      "using mint = LazyMontgomeryModInt<MOD>;",
      "using vm = vector<mint>;",
      "NTT<mint> ntt;",
      "using FPS = FormalPowerSeries<mint>;",
      "auto mult = [&](const FPS::P &a, const FPS::P &b) {",
      "  auto ret = ntt.multiply(a, b);",
      "  return FPS::P(ret.begin(), ret.end());",
      "};",
      "FPS::set_mult(mult);",
      "FPS::set_fft([&](FPS::P &a) { ntt.ntt(a); }, [&](FPS::P &a) { ntt.intt(a); });",
      "//*/",
      "",
      "// if mod is constant mod (prime, 3 <= mod < 2^30)",
      "/**",
      "using mint = LazyMontgomeryModInt<MOD>;",
      "using vm = vector<mint>;",
      "using FPS = FormalPowerSeries<mint>;",
      "auto mult = [&](const FPS::P &a, const FPS::P &b) {",
      "  vm ret = ArbitraryNTT::multiply<MOD>(a, b);",
      "  return FPS::P(ret.begin(), ret.end());",
      "};",
      "FPS::set_mult(mult);",
      "//*/",
      "",
      "// otherwise",
      "/**",
      "using mint = ArbitraryModInt;",
      "using vm = vector<mint>;",
      "using FPS = FormalPowerSeries<mint>;",
      "auto mult = [&](const FPS::P &a, const FPS::P &b) {",
      "  vm ret = ArbitraryNTT::multiply(a, b);",
      "  return FPS::P(ret.begin(), ret.end());",
      "};",
      "FPS::set_mult(mult);",
      "//*/"
    ],
    "description": "Formal_Power_Series"
  },
  "Formal_Power_Series_old": {
    "prefix": "_old_FormalPowerSeries",
    "body": [
      "template< int mod >",
      "struct ModInt {",
      "  int x;",
      "",
      "  ModInt() : x(0) {}",
      "",
      "  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}",
      "",
      "  ModInt &operator+=(const ModInt &p) {",
      "    if((x += p.x) >= mod) x -= mod;",
      "    return *this;",
      "  }",
      "",
      "  ModInt &operator-=(const ModInt &p) {",
      "    if((x += mod - p.x) >= mod) x -= mod;",
      "    return *this;",
      "  }",
      "",
      "  ModInt &operator*=(const ModInt &p) {",
      "    x = (int) (1LL * x * p.x % mod);",
      "    return *this;",
      "  }",
      "",
      "  ModInt &operator/=(const ModInt &p) {",
      "    *this *= p.inverse();",
      "    return *this;",
      "  }",
      "",
      "  ModInt operator-() const { return ModInt(-x); }",
      "",
      "  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }",
      "",
      "  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }",
      "",
      "  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }",
      "",
      "  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }",
      "",
      "  bool operator==(const ModInt &p) const { return x == p.x; }",
      "",
      "  bool operator!=(const ModInt &p) const { return x != p.x; }",
      "",
      "  ModInt inverse() const {",
      "    int a = x, b = mod, u = 1, v = 0, t;",
      "    while(b > 0) {",
      "      t = a / b;",
      "      swap(a -= t * b, b);",
      "      swap(u -= t * v, v);",
      "    }",
      "    return ModInt(u);",
      "  }",
      "",
      "  ModInt pow(int64_t n) const {",
      "    ModInt ret(1), mul(x);",
      "    while(n > 0) {",
      "      if(n & 1) ret *= mul;",
      "      mul *= mul;",
      "      n >>= 1;",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  friend ostream &operator<<(ostream &os, const ModInt &p) {",
      "    return os << p.x;",
      "  }",
      "",
      "  friend istream &operator>>(istream &is, ModInt &a) {",
      "    int64_t t;",
      "    is >> t;",
      "    a = ModInt< mod >(t);",
      "    return (is);",
      "  }",
      "",
      "  static int get_mod() { return mod; }",
      "};",
      "",
      "using modint = ModInt< MOD >;",
      "using mint = modint;",
      "using vm = vector<mint>;",
      "",
      "namespace FastFourierTransform {",
      "  using real = double;",
      "",
      "  struct C {",
      "    real x, y;",
      "",
      "    C() : x(0), y(0) {}",
      "",
      "    C(real x, real y) : x(x), y(y) {}",
      "",
      "    inline C operator+(const C &c) const { return C(x + c.x, y + c.y); }",
      "",
      "    inline C operator-(const C &c) const { return C(x - c.x, y - c.y); }",
      "",
      "    inline C operator*(const C &c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }",
      "",
      "    inline C conj() const { return C(x, -y); }",
      "  };",
      "",
      "  const real PI = acosl(-1);",
      "  int base = 1;",
      "  vector< C > rts = { {0, 0},",
      "                     {1, 0} };",
      "  vector< int > rev = {0, 1};",
      "",
      "",
      "  void ensure_base(int nbase) {",
      "    if(nbase <= base) return;",
      "    rev.resize(1 << nbase);",
      "    rts.resize(1 << nbase);",
      "    for(int i = 0; i < (1 << nbase); i++) {",
      "      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));",
      "    }",
      "    while(base < nbase) {",
      "      real angle = PI * 2.0 / (1 << (base + 1));",
      "      for(int i = 1 << (base - 1); i < (1 << base); i++) {",
      "        rts[i << 1] = rts[i];",
      "        real angle_i = angle * (2 * i + 1 - (1 << base));",
      "        rts[(i << 1) + 1] = C(cos(angle_i), sin(angle_i));",
      "      }",
      "      ++base;",
      "    }",
      "  }",
      "",
      "  void fft(vector< C > &a, int n) {",
      "    assert((n & (n - 1)) == 0);",
      "    int zeros = __builtin_ctz(n);",
      "    ensure_base(zeros);",
      "    int shift = base - zeros;",
      "    for(int i = 0; i < n; i++) {",
      "      if(i < (rev[i] >> shift)) {",
      "        swap(a[i], a[rev[i] >> shift]);",
      "      }",
      "    }",
      "    for(int k = 1; k < n; k <<= 1) {",
      "      for(int i = 0; i < n; i += 2 * k) {",
      "        for(int j = 0; j < k; j++) {",
      "          C z = a[i + j + k] * rts[j + k];",
      "          a[i + j + k] = a[i + j] - z;",
      "          a[i + j] = a[i + j] + z;",
      "        }",
      "      }",
      "    }",
      "  }",
      "",
      "  vector< int64_t > multiply(const vector< int > &a, const vector< int > &b) {",
      "    int need = (int) a.size() + (int) b.size() - 1;",
      "    int nbase = 1;",
      "    while((1 << nbase) < need) nbase++;",
      "    ensure_base(nbase);",
      "    int sz = 1 << nbase;",
      "    vector< C > fa(sz);",
      "    for(int i = 0; i < sz; i++) {",
      "      int x = (i < (int) a.size() ? a[i] : 0);",
      "      int y = (i < (int) b.size() ? b[i] : 0);",
      "      fa[i] = C(x, y);",
      "    }",
      "    fft(fa, sz);",
      "    C r(0, -0.25 / (sz >> 1)), s(0, 1), t(0.5, 0);",
      "    for(int i = 0; i <= (sz >> 1); i++) {",
      "      int j = (sz - i) & (sz - 1);",
      "      C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;",
      "      fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;",
      "      fa[i] = z;",
      "    }",
      "    for(int i = 0; i < (sz >> 1); i++) {",
      "      C A0 = (fa[i] + fa[i + (sz >> 1)]) * t;",
      "      C A1 = (fa[i] - fa[i + (sz >> 1)]) * t * rts[(sz >> 1) + i];",
      "      fa[i] = A0 + A1 * s;",
      "    }",
      "    fft(fa, sz >> 1);",
      "    vector< int64_t > ret(need);",
      "    for(int i = 0; i < need; i++) {",
      "      ret[i] = llround(i & 1 ? fa[i >> 1].y : fa[i >> 1].x);",
      "    }",
      "    return ret;",
      "  }",
      "};",
      "",
      "template< typename T >",
      "struct ArbitraryModConvolution {",
      "  using real = FastFourierTransform::real;",
      "  using C = FastFourierTransform::C;",
      "",
      "  ArbitraryModConvolution() = default;",
      "",
      "  vector< T > multiply(const vector< T > &a, const vector< T > &b, int need = -1) {",
      "    if(need == -1) need = a.size() + b.size() - 1;",
      "    int nbase = 0;",
      "    while((1 << nbase) < need) nbase++;",
      "    FastFourierTransform::ensure_base(nbase);",
      "    int sz = 1 << nbase;",
      "    vector< C > fa(sz);",
      "    for(int i = 0; i < (int)a.size(); i++) {",
      "      fa[i] = C(a[i].x & ((1 << 15) - 1), a[i].x >> 15);",
      "    }",
      "    fft(fa, sz);",
      "    vector< C > fb(sz);",
      "    if(a == b) {",
      "      fb = fa;",
      "    } else {",
      "      for(int i = 0; i < (int)b.size(); i++) {",
      "        fb[i] = C(b[i].x & ((1 << 15) - 1), b[i].x >> 15);",
      "      }",
      "      fft(fb, sz);",
      "    }",
      "    real ratio = 0.25 / sz;",
      "    C r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);",
      "    for(int i = 0; i <= (sz >> 1); i++) {",
      "      int j = (sz - i) & (sz - 1);",
      "      C a1 = (fa[i] + fa[j].conj());",
      "      C a2 = (fa[i] - fa[j].conj()) * r2;",
      "      C b1 = (fb[i] + fb[j].conj()) * r3;",
      "      C b2 = (fb[i] - fb[j].conj()) * r4;",
      "      if(i != j) {",
      "        C c1 = (fa[j] + fa[i].conj());",
      "        C c2 = (fa[j] - fa[i].conj()) * r2;",
      "        C d1 = (fb[j] + fb[i].conj()) * r3;",
      "        C d2 = (fb[j] - fb[i].conj()) * r4;",
      "        fa[i] = c1 * d1 + c2 * d2 * r5;",
      "        fb[i] = c1 * d2 + c2 * d1;",
      "      }",
      "      fa[j] = a1 * b1 + a2 * b2 * r5;",
      "      fb[j] = a1 * b2 + a2 * b1;",
      "    }",
      "    fft(fa, sz);",
      "    fft(fb, sz);",
      "    vector< T > ret(need);",
      "    for(int i = 0; i < need; i++) {",
      "      int64_t aa = llround(fa[i].x);",
      "      int64_t bb = llround(fb[i].x);",
      "      int64_t cc = llround(fa[i].y);",
      "      aa = T(aa).x, bb = T(bb).x, cc = T(cc).x;",
      "      ret[i] = aa + (bb << 15) + (cc << 30);",
      "    }",
      "    return ret;",
      "  }",
      "};",
      "",
      "template< int mod >",
      "struct NumberTheoreticTransform {",
      "",
      "  int base, max_base, root;",
      "  vector< int > rev, rts;",
      "",
      "  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {",
      "    assert(mod >= 3 && mod % 2 == 1);",
      "    auto tmp = mod - 1;",
      "    max_base = 0;",
      "    while(tmp % 2 == 0) tmp >>= 1, max_base++;",
      "    root = 2;",
      "    while(mod_pow(root, (mod - 1) >> 1) == 1) ++root;",
      "    assert(mod_pow(root, mod - 1) == 1);",
      "    root = mod_pow(root, (mod - 1) >> max_base);",
      "  }",
      "",
      "  inline int mod_pow(int x, int n) {",
      "    int ret = 1;",
      "    while(n > 0) {",
      "      if(n & 1) ret = mul(ret, x);",
      "      x = mul(x, x);",
      "      n >>= 1;",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  inline int inverse(int x) {",
      "    return mod_pow(x, mod - 2);",
      "  }",
      "",
      "  inline unsigned add(unsigned x, unsigned y) {",
      "    x += y;",
      "    if(x >= mod) x -= mod;",
      "    return x;",
      "  }",
      "",
      "  inline unsigned mul(unsigned a, unsigned b) {",
      "    return 1ull * a * b % (unsigned long long) mod;",
      "  }",
      "",
      "  void ensure_base(int nbase) {",
      "    if(nbase <= base) return;",
      "    rev.resize(1 << nbase);",
      "    rts.resize(1 << nbase);",
      "    for(int i = 0; i < (1 << nbase); i++) {",
      "      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));",
      "    }",
      "    assert(nbase <= max_base);",
      "    while(base < nbase) {",
      "      int z = mod_pow(root, 1 << (max_base - 1 - base));",
      "      for(int i = 1 << (base - 1); i < (1 << base); i++) {",
      "        rts[i << 1] = rts[i];",
      "        rts[(i << 1) + 1] = mul(rts[i], z);",
      "      }",
      "      ++base;",
      "    }",
      "  }",
      "",
      "",
      "  void ntt(vector< int > &a) {",
      "    const int n = (int) a.size();",
      "    assert((n & (n - 1)) == 0);",
      "    int zeros = __builtin_ctz(n);",
      "    ensure_base(zeros);",
      "    int shift = base - zeros;",
      "    for(int i = 0; i < n; i++) {",
      "      if(i < (rev[i] >> shift)) {",
      "        swap(a[i], a[rev[i] >> shift]);",
      "      }",
      "    }",
      "    for(int k = 1; k < n; k <<= 1) {",
      "      for(int i = 0; i < n; i += 2 * k) {",
      "        for(int j = 0; j < k; j++) {",
      "          int z = mul(a[i + j + k], rts[j + k]);",
      "          a[i + j + k] = add(a[i + j], mod - z);",
      "          a[i + j] = add(a[i + j], z);",
      "        }",
      "      }",
      "    }",
      "  }",
      "",
      "",
      "  vector< int > multiply(vector< int > a, vector< int > b) {",
      "    int need = a.size() + b.size() - 1;",
      "    int nbase = 1;",
      "    while((1 << nbase) < need) nbase++;",
      "    ensure_base(nbase);",
      "    int sz = 1 << nbase;",
      "    a.resize(sz, 0);",
      "    b.resize(sz, 0);",
      "    ntt(a);",
      "    ntt(b);",
      "    int inv_sz = inverse(sz);",
      "    for(int i = 0; i < sz; i++) {",
      "      a[i] = mul(a[i], mul(b[i], inv_sz));",
      "    }",
      "    reverse(a.begin() + 1, a.end());",
      "    ntt(a);",
      "    a.resize(need);",
      "    return a;",
      "  }",
      "",
      "  vector<modint> multiply_for_fps(const vector<modint> &a,const vector<modint> &b){",
      "    vector<int> A(a.size()) , B(b.size());",
      "    for(int i = 0;i < (int)a.size(); i++) A[i] = a[i].x;",
      "    for(int i = 0;i < (int)b.size(); i++) B[i] = b[i].x;",
      "    auto C = multiply( A , B );",
      "    vector<modint> ret(C.size());",
      "    for(int i = 0; i < (int)C.size() ;i++) ret[i].x = C[i];",
      "    return ret;",
      "  }",
      "};",
      "",
      "",
      "template< typename T >",
      "struct FormalPowerSeries : vector< T > {",
      "  using vector< T >::vector;",
      "  using P = FormalPowerSeries;",
      "",
      "  using MULT = function< P(P, P) >;",
      "",
      "  static MULT &get_mult() {",
      "    static MULT mult = nullptr;",
      "    return mult;",
      "  }",
      "",
      "  static void set_fft(MULT f) {",
      "    get_mult() = f;",
      "  }",
      "",
      "  void shrink() {",
      "    while(this->size() && this->back() == T(0)) this->pop_back();",
      "  }",
      "",
      "  P operator+(const P &r) const { return P(*this) += r; }",
      "",
      "  P operator+(const T &v) const { return P(*this) += v; }",
      "",
      "  P operator-(const P &r) const { return P(*this) -= r; }",
      "",
      "  P operator-(const T &v) const { return P(*this) -= v; }",
      "",
      "  P operator*(const P &r) const { return P(*this) *= r; }",
      "",
      "  P operator*(const T &v) const { return P(*this) *= v; }",
      "",
      "  P operator/(const P &r) const { return P(*this) /= r; }",
      "",
      "  P operator%(const P &r) const { return P(*this) %= r; }",
      "",
      "  P &operator+=(const P &r) {",
      "    if(r.size() > this->size()) this->resize(r.size());",
      "    for(int i = 0; i < (int)r.size(); i++) (*this)[i] += r[i];",
      "    return *this;",
      "  }",
      "",
      "  P &operator+=(const T &r) {",
      "    if(this->empty()) this->resize(1);",
      "    (*this)[0] += r;",
      "    return *this;",
      "  }",
      "",
      "  P &operator-=(const P &r) {",
      "    if(r.size() > this->size()) this->resize(r.size());",
      "    for(int i = 0; i < (int)r.size(); i++) (*this)[i] -= r[i];",
      "    shrink();",
      "    return *this;",
      "  }",
      "",
      "  P &operator-=(const T &r) {",
      "    if(this->empty()) this->resize(1);",
      "    (*this)[0] -= r;",
      "    shrink();",
      "    return *this;",
      "  }",
      "",
      "  P &operator*=(const T &v) {",
      "    const int n = (int) this->size();",
      "    for(int k = 0; k < n; k++) (*this)[k] *= v;",
      "    return *this;",
      "  }",
      "",
      "  P &operator*=(const P &r) {",
      "    if(this->empty() || r.empty()) {",
      "      this->clear();",
      "      return *this;",
      "    }",
      "    assert(get_mult() != nullptr);",
      "    return *this = get_mult()(*this, r);",
      "  }",
      "",
      "  P &operator%=(const P &r) {",
      "    return *this -= *this / r * r;",
      "  }",
      "",
      "  P operator-() const {",
      "    P ret(this->size());",
      "    for(int i = 0; i < this->size(); i++) ret[i] = -(*this)[i];",
      "    return ret;",
      "  }",
      "",
      "  P &operator/=(const P &r) {",
      "    if(this->size() < r.size()) {",
      "      this->clear();",
      "      return *this;",
      "    }",
      "    int n = this->size() - r.size() + 1;",
      "    return *this = (rev().pre(n) * r.rev().inv(n)).pre(n).rev(n);",
      "  }",
      "",
      "  P pre(int sz) const {",
      "    return P(begin(*this), begin(*this) + min((int) this->size(), sz));",
      "  }",
      "",
      "  P operator>>(int sz) const {",
      "    if(this->size() <= sz) return {};",
      "    P ret(*this);",
      "    ret.erase(ret.begin(), ret.begin() + sz);",
      "    return ret;",
      "  }",
      "",
      "  P operator<<(int sz) const {",
      "    P ret(*this);",
      "    ret.insert(ret.begin(), sz, T(0));",
      "    return ret;",
      "  }",
      "",
      "  P rev(int deg = -1) const {",
      "    P ret(*this);",
      "    if(deg != -1) ret.resize(deg, T(0));",
      "    reverse(begin(ret), end(ret));",
      "    return ret;",
      "  }",
      "",
      "  P diff() const {",
      "    const int n = (int) this->size();",
      "    P ret(max(0, n - 1));",
      "    for(int i = 1; i < n; i++) ret[i - 1] = (*this)[i] * T(i);",
      "    return ret;",
      "  }",
      "",
      "  P integral() const {",
      "    const int n = (int) this->size();",
      "    P ret(n + 1);",
      "    ret[0] = T(0);",
      "    for(int i = 0; i < n; i++) ret[i + 1] = (*this)[i] / T(i + 1);",
      "    return ret;",
      "  }",
      "",
      "  // F(0) must not be 0",
      "  P inv(int deg = -1) const {",
      "    assert(((*this)[0]) != T(0));",
      "    const int n = (int) this->size();",
      "    if(deg == -1) deg = n;",
      "    P ret({T(1) / (*this)[0]});",
      "    for(int i = 1; i < deg; i <<= 1) {",
      "      ret = (ret + ret - ret * ret * pre(i << 1)).pre(i << 1);",
      "    }",
      "    return ret.pre(deg);",
      "  }",
      "",
      "  // F(0) must be 1",
      "  P log(int deg = -1) const {",
      "    assert((*this)[0] == 1);",
      "    const int n = (int) this->size();",
      "    if(deg == -1) deg = n;",
      "    return (this->diff() * this->inv(deg)).pre(deg - 1).integral();",
      "  }",
      "",
      "  P sqrt(int deg = -1) const {",
      "    const int n = (int) this->size();",
      "    if(deg == -1) deg = n;",
      "",
      "    if((*this)[0] == T(0)) {",
      "      for(int i = 1; i < n; i++) {",
      "        if((*this)[i] != T(0)) {",
      "          if(i & 1) return {};",
      "          if(deg - i / 2 <= 0) break;",
      "          auto ret = (*this >> i).sqrt(deg - i / 2) << (i / 2);",
      "          if(ret.size() < deg) ret.resize(deg, T(0));",
      "          return ret;",
      "        }",
      "      }",
      "      return P(deg, 0);",
      "    }",
      "",
      "    P ret({T(1)});",
      "    T inv2 = T(1) / T(2);",
      "    for(int i = 1; i < deg; i <<= 1) {",
      "      ret = (ret + pre(i << 1) * ret.inv(i << 1)) * inv2;",
      "    }",
      "    return ret.pre(deg);",
      "  }",
      "",
      "  // F(0) must be 0",
      "  P exp(int deg = -1) const {",
      "    assert((*this)[0] == T(0));",
      "    const int n = (int) this->size();",
      "    if(deg == -1) deg = n;",
      "    P ret({T(1)});",
      "    for(int i = 1; i < deg; i <<= 1) {",
      "      ret = (ret * (pre(i << 1) + T(1) - ret.log(i << 1))).pre(i << 1);",
      "    }",
      "    return ret.pre(deg);",
      "  }",
      "",
      "  P pow(int64_t k, int deg = -1) const {",
      "    const int n = (int) this->size();",
      "    if(deg == -1) deg = n;",
      "    for(int i = 0; i < n; i++) {",
      "      if((*this)[i] != T(0)) {",
      "        T rev = T(1) / (*this)[i];",
      "        P C(*this * rev);",
      "        P D(n - i);",
      "        for(int j = i; j < n; j++) D[j - i] = C[j];",
      "        D = (D.log() * k).exp() * (*this)[i].pow(k);",
      "        P E(deg);",
      "        if(i * k > deg) return E;",
      "        auto S = i * k;",
      "        for(int j = 0; j + S < deg && j < D.size(); j++) E[j + S] = D[j];",
      "        return E;",
      "      }",
      "    }",
      "    return *this;",
      "  }",
      "",
      "  T eval(T x) const {",
      "    T r = 0, w = 1;",
      "    for(auto &v : *this) {",
      "      r += w * v;",
      "      w *= x;",
      "    }",
      "    return r;",
      "  }",
      "};",
      "",
      "using FPS = FormalPowerSeries< modint >;",
      "",
      "// fにa * x^n + bを掛ける",
      "void mul_simple(FPS &f,modint a ,int n, modint b){",
      "  for(int i = (int)f.size() - 1 ; i >= 0 ; i--){",
      "    f[i] *= b;",
      "    if(i >= n) f[i] += f[i - n] * a; ",
      "  }",
      "}",
      "",
      "// fからa * x^n + bを割る",
      "void div_simple(FPS &f,modint a,int n,modint b){",
      "  for(int i = 0 ; i < (int)f.size() ; i++){",
      "    f[i] /= b;",
      "    if(i + n < (int)f.size() ) f[n + i] -= f[i] * a; ",
      "  }",
      "}",
      "",
      "// f / gをdeg(f)次まで求める",
      "FPS div_(FPS &f , FPS g){",
      "  int n = f.size();",
      "  return (f * g.inv(n)).pre(n);",
      "}",
      "",
      "",
      "// solve関数内で",
      "//",
      "// FPS::set_fft(mul);",
      "//",
      "// とすること。",
      "",
      "/**/",
      "NumberTheoreticTransform<MOD> ntt;",
      "auto mul = [&](const FPS::P &a, const FPS::P &b) {",
      "  auto ret =ntt.multiply_for_fps(a , b);",
      "  return FPS::P(ret.begin(), ret.end());",
      "};",
      "/*///",
      "ArbitraryModConvolution< modint > fft;",
      "auto mul = [&](const FPS::P &a, const FPS::P &b) {",
      "  auto ret = fft.multiply(a, b);",
      "  return FPS::P(ret.begin(), ret.end());",
      "};",
      "//*/",
      "",
      "// 下記のリンクを実装(kitamasa法のモンゴメリ乗算を使わない版)",
      "// http://q.c.titech.ac.jp/docs/progs/polynomial_division.html",
      "// k項間漸化式のa_Nを求める O(k log k log N)",
      "// N ... 求めたい項　(0-indexed)",
      "// Q ... 漸化式 (1 - \\sum_i c_i x^i)の形",
      "// a ... 初期解 (a_0 , a_1 , ... , a_k-1)",
      "// x^N を fでわった剰余を求め、aと内積を取る",
      "modint kitamasa(ll N, FPS &Q, FPS &a){",
      "  int k = Q.size() - 1;",
      "  assert( (int)a.size() == k );",
      "  FPS P = a * Q; P.resize(k);",
      "  while(N){",
      "    auto Q2 = Q;",
      "    for(int i = 1; i < (int)Q2.size(); i += 2) Q2[i].x = MOD - Q2[i].x;",
      "    auto S = P * Q2;",
      "    auto T = Q * Q2;",
      "    if(N & 1){",
      "      for(int i = 1 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;",
      "      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;",
      "    }",
      "    else{",
      "      for(int i = 0 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;",
      "      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;",
      "    }",
      "    N >>= 1;",
      "  }",
      "  return P[0];",
      "}"
    ],
    "description": "Formal_Power_Series"
  },
  "Mo's_algorithm": {
    "prefix": "_Mo",
    "body": [
      "",
      "struct Mo {",
      "  int width;",
      "  vector< int > left, right, order;",
      "  vector< bool > v;",
      "",
      "  Mo(int N, int Q) : width((int) sqrt(N)), order(Q), v(N) {",
      "    iota(begin(order), end(order), 0);",
      "  }",
      "",
      "  void insert(int l, int r) { /* [l, r) */",
      "    left.emplace_back(l);",
      "    right.emplace_back(r);",
      "  }",
      "",
      "  template<typename ADD,typename DEL,typename REM>",
      "  void run(const ADD &add, const DEL &del, const REM &rem) {",
      "    assert(left.size() == order.size());",
      "    sort(begin(order), end(order), [&](int a, int b) {",
      "      int ablock = left[a] / width, bblock = left[b] / width;",
      "      if(ablock != bblock) return ablock < bblock;",
      "      if(ablock & 1) return right[a] < right[b];",
      "      return right[a] > right[b];",
      "    });",
      "    int nl = 0, nr = 0;",
      "    auto push = [&](int idx) {",
      "      v[idx].flip();",
      "      if(v[idx]) add(idx);",
      "      else del(idx);",
      "    };",
      "    for(auto idx : order) {",
      "      while(nl > left[idx]) push(--nl);",
      "      while(nr < right[idx]) push(nr++);",
      "      while(nl < left[idx]) push(nl++);",
      "      while(nr > right[idx]) push(--nr);",
      "      rem(idx);",
      "    }",
      "  }",
      "};"
    ],
    "description": "Mo's_algorithm"
  },
  "F2_Linear_Algebra": {
    "prefix": "_f2",
    "body": [
      "template <size_t N>",
      "bitset<N> gcd(bitset<N> x, bitset<N> y) {",
      "  int xm = int(N) - 1, ym = int(N) - 1;",
      "  while (xm != -1 && x[xm] == 0) xm--;",
      "  while (ym != -1 && y[ym] == 0) ym--;",
      "  if (xm < ym) swap(x, y), swap(xm, ym);",
      "  while (ym >= 0) {",
      "    x ^= y << (xm - ym);",
      "    while (xm != -1 && x[xm] == 0) xm--;",
      "    while (ym != -1 && y[ym] == 0) ym--;",
      "    if (xm < ym) swap(x, y), swap(xm, ym);",
      "  }",
      "  return x;",
      "}",
      "",
      "template <size_t MAX_H, size_t MAX_W>",
      "struct BitMat {",
      "  int H, W;",
      "  bitset<MAX_W> a[MAX_H];",
      "  BitMat(int h, int w) : H(h), W(w) {}",
      "  inline bitset<MAX_W> &operator[](int i) { return a[i]; }",
      "};",
      "",
      "template <size_t MAX_H, size_t MAX_W>",
      "int Gauss(BitMat<MAX_H, MAX_W> &A, bool is_greater = true,",
      "          bool is_extended = false) {",
      "  int rank = 0, H = A.H, W = (is_extended ? A.W - 1 : A.W);",
      "  for (int j = (is_greater ? W - 1 : 0); j != (is_greater ? -1 : W);",
      "       j += (is_greater ? -1 : 1)) {",
      "    for (int i = rank; i < H; i++) {",
      "      if (A[i][j] == 1) {",
      "        swap(A[rank], A[i]);",
      "        for (int k = 0; k < H; k++) {",
      "          if (k != rank && A[k][j]) A[k] ^= A[rank];",
      "        }",
      "        rank++;",
      "        break;",
      "      }",
      "    }",
      "  }",
      "  if (is_extended) {",
      "    for (int i = rank; i < H; i++)",
      "      if (A[i][W] == 1) return -1;",
      "  }",
      "  return rank;",
      "}",
      "template <size_t MAX_H, size_t MAX_W>",
      "void OrthogonalComplement(BitMat<MAX_H, MAX_W> &A, int N) {",
      "  int rank = 0;",
      "  while (rank < N && A[rank].any()) rank++;",
      "  for (int i = 0; i < rank; i++) {",
      "    int j = A[i]._Find_first();",
      "    if (j != i)",
      "      for (int k = 0; k < rank; k++) {",
      "        int buf = A[k][i];",
      "        A[k][i] = A[k][j];",
      "        A[k][j] = buf;",
      "      }",
      "  }",
      "  for (int i = rank; i < N; i++) {",
      "    for (int j = 0; j < N; j++) {",
      "      A[i][j] = (j < rank ? A[j][i] : i == j);",
      "    }",
      "  }",
      "}"
    ],
    "description": "F2_Linear_Algebra"
  },
  "bit_operation": {
    "prefix": "_bitoperation",
    "body": [
      "// 立っているビットの数",
      "inline int popcnt(unsigned long long a){ return __builtin_popcountll(a); }",
      "// 一番右側のbit(1の位を0番目とする)",
      "inline int ctz(unsigned long long a){ return __builtin_ctzll(a); }",
      "// 一番左側のbit",
      "inline int msb(unsigned long long a){ return 63 - __builtin_clzll(a); }",
      "// i番目のビットが立っているか",
      "template<typename T>inline int getbit(T a ,int i){ return (a >> i) & 1; }",
      "// i番目のビットを立たせる",
      "template<typename T>inline void setbit(T &a,int i){ a |= (1LL << i); }",
      "// i番目のビットを消す",
      "template<typename T>inline void delbit(T &a,int i){ a &= ~(1LL << i); }"
    ],
    "description": "bit_operation"
  },
  "Union_Find_With_Potential": {
    "prefix": "_UF_with_pot",
    "body": [
      "",
      "// PotentialつきUnion-Find",
      "template<class T>",
      "struct UnionFindWithPotential{",
      "  vector<int> par , rank;",
      "  // pot...根に対するポテンシャル",
      "  vector<T> pot;",
      "  T UNIT;",
      "  ",
      "  UnionFindWithPotential(int N , T UNIT_ = 0) : par(N) , rank(N) , pot(N) , UNIT(UNIT_){",
      "    for(int i = 0 ; i < N ; i++) par[i] = i , rank[i] = 0 , pot[i] = UNIT;",
      "  }",
      "",
      "  // xの根を返す関数",
      "  int root(int x) {",
      "    if(par[x] == x) return x;",
      "    int r = root(par[x]);",
      "    pot[x] += pot[par[x]];",
      "    return par[x] = r;",
      "  }",
      "",
      "  // 根に対するポテンシャルを返す関数",
      "  T potential(int x){ root(x); return pot[x];}",
      "  ",
      "  // 根が同じかを判定する関数",
      "  bool same(int x,int y){return root(x) == root(y);}",
      "",
      "  // xのyに対するpotentialを返す関数",
      "  T diff(int x,int y){return potential(x) - potential(y);}",
      "",
      "  // xのyに対するpotentialがpである (xはyよりもp大きい)",
      "  // falseの時、既存の情報と矛盾",
      "  bool merge(int x,int y,T p){",
      "    p += potential(y) - potential(x);",
      "    x = root(x) , y = root(y);",
      "    if(x == y){return p == UNIT;}",
      "    if (rank[x] > rank[y]) swap(x, y) , p = -p;",
      "    if (rank[x] == rank[y]) ++rank[x];",
      "    par[x] = y , pot[x] = p;",
      "    return true;",
      "  }",
      "",
      "};"
    ],
    "description": "Union_Find_With_Potential"
  },
  "Square_Decomposition": {
    "prefix": "_SquareRootDecomposition",
    "body": [
      "",
      "constexpr int B = 300;",
      "",
      "struct block{",
      "",
      "  // S 更新用 T 取得用",
      "  using S = ll;",
      "  using T = ll;",
      "",
      "  // 各種変数の初期化を忘れない！！！",
      "  block(){",
      "",
      "  }",
      "",
      "  void build(){",
      "",
      "  }",
      "",
      "  void update_all(S x){",
      "",
      "  }",
      "  ",
      "  void update_part(int l,int r, S x){",
      "",
      "    build();",
      "  }",
      "",
      "  T query_all(){",
      "",
      "  }",
      "  ",
      "  T query_part(int l,int r){",
      "  ",
      "  }",
      "",
      "};",
      "",
      "// 取得クエリのマージ関数をf、単位元をUNITとする",
      "template <typename F> struct Sqd{",
      "  int N;",
      "  V<block> sq;",
      "  F f;",
      "  block::T UNIT;",
      "  Sqd(int N , F f, block::T UNIT) : N(N) , sq(N / B + 1) , f(f) , UNIT(UNIT) {",
      "    init();",
      "    for(auto &x : sq) x.build();",
      "  }",
      "",
      "  void init(){",
      "",
      "  }",
      "",
      "  // 半開区間[ l , r )に対する更新クエリ",
      "  void update(int l , int r , block::S x){",
      "    if(l / B == r / B) {",
      "      sq[l / B].update_part(l % B , r % B , x);",
      "    }",
      "    else {",
      "      sq[l / B].update_part(l % B , B , x);",
      "      for(int i = l / B + 1 ; i < r / B ; i++) sq[i].update_all(x);",
      "      sq[r / B].update_part(0 , r % B , x);",
      "    }",
      "  }",
      "",
      "  // 半開区間[ l , r )に対する取得クエリ",
      "  block::T query(int l,int r){",
      "    if(l / B == r / B)",
      "      return sq[l / B].query_part(l % B , r % B);",
      "    block::T ret = UNIT;",
      "    ret = f( ret , sq[l / B].query_part(l % B , B) );",
      "    for(int i = l / B + 1 ; i < r / B ; i++) ",
      "      ret = f(ret , sq[i].query_all() );",
      "    ret = f( ret , sq[r / B].query_part(0 , r % B) );",
      "    return ret;",
      "  }",
      "",
      "};"
    ],
    "description": "Square_Decomposition"
  },
  "dfs_template": {
    "prefix": "_dfs",
    "body": [
      "auto ${1:dfs} = [&](auto rec,int cur,int par = -1) -> void{",
      "  $0  ",
      "  each(dst , g[cur]){",
      "    if(dst == par) continue;",
      "    rec(rec , dst , cur);",
      "  }",
      "",
      "};",
      "${1:dfs}(${1:dfs} , 0);"
    ],
    "description": "dfs_template"
  },
  "Accumulated_Sum": {
    "prefix": "_ruiseki",
    "body": [
      "auto mkrui = [](auto v) -> decltype(v){",
      "  decltype(v) ret(v.size() + 1);",
      "  for(int i = 0 ; i < int(v.size()) ; i++) ",
      "    ret[i + 1] = ret[i] + v[i];",
      "  return ret;",
      "};",
      "auto rui = mkrui($1);",
      "$0"
    ],
    "description": "Accumulated_Sum"
  },
  "make_order": {
    "prefix": "_order",
    "body": [
      "auto mkord = [&](int n , auto f) -> vector<int>{",
      "  vector<int> ord(n);",
      "  iota(begin(ord) , end(ord) , 0);",
      "  sort(begin(ord) , end(ord) , f);",
      "  return ord;",
      "};",
      "vector<int> ord = mkord($1.size(), [&](int x,int y){",
      "  return $2;",
      "});",
      "$0"
    ],
    "description": "make_order"
  },
  "modulo_pow": {
    "prefix": "_modpow",
    "body": [
      "auto modpow = [](ll a,ll n,ll mod) -> ll{",
      "  a %= mod;",
      "  ll ret = 1;",
      "  while(n > 0){",
      "    if(n & 1) ret = ret * a % mod;",
      "    a = a * a % mod;",
      "    n >>= 1;",
      "  }",
      "  return ret % mod;",
      "};"
    ],
    "description": "modulo_pow"
  },
  "breadth_first_search": {
    "prefix": "_bfs",
    "body": [
      "",
      "// bfs",
      "template<typename T>",
      "vector<T> bfs(vvi &g, int start = 0){ ",
      "  int N = (int)g.size();",
      "  T INF = numeric_limits<T>::max() / 2;",
      "  vector<T> d(N , INF);",
      "  d[start] = 0;",
      "  queue<int> Q;",
      "  Q.push(start);",
      "  while(!Q.empty()){",
      "    int cur = Q.front(); Q.pop();",
      "    for(auto dst : g[cur]){",
      "      if(d[dst] != INF) continue;",
      "      d[dst] = d[cur] + 1;",
      "      Q.push(dst);",
      "    }",
      "  }",
      "  return d;",
      "}"
    ],
    "description": "breadth_first_search"
  },
  "lambda_function": {
    "prefix": "_lambda",
    "body": [
      "auto ${1:f} = [&](${2:ll n}) -> ${3:void}{",
      "  $0",
      "};"
    ],
    "description": "lambda_function"
  },
  "binary_search": {
    "prefix": "_nibutan",
    "body": [
      "auto func = [&](ll n) -> int{",
      "  $0",
      "};",
      "ll ok = $1 , ng = $2;",
      "while(min(ng , ok) + 1 < max(ng , ok)){",
      "  ll med = (ng + ok) / 2;",
      "  ( func(med) ? ok : ng ) = med;",
      "}"
    ],
    "description": "binary_search"
  },
  "Run_Length_Encoding": {
    "prefix": "_runlength",
    "body": [
      "",
      "vector<pair<char,int>> RunLengthEncoding(string& S){",
      "  vector<pair<char,int>> ret;",
      "  char c = -1;",
      "  int n = 0;",
      "  for(char x : S){",
      "    if(c == x) n++;",
      "    else{",
      "      if(n) ret.emplace_back(c , n);",
      "      c = x , n = 1;",
      "    }",
      "  }",
      "  if(n) ret.emplace_back(c , n);",
      "  return ret;",
      "}",
      "",
      "template<typename T>",
      "vector<pair<T,int>> RunLengthEncoding(vector<T>& S){",
      "  vector<pair<T,int>> ret;",
      "  T c = -1;",
      "  int n = 0;",
      "  for(T& x : S){",
      "    if(c == x) n++;",
      "    else{",
      "      if(n) ret.emplace_back(c , n);",
      "      c = x , n = 1;",
      "    }",
      "  }",
      "  if(n) ret.emplace_back(c , n);",
      "  return ret;",
      "}"
    ],
    "description": "Run_Length_Encoding"
  },
  "_kruskal's_algorithm": {
    "prefix": "_kruskal",
    "body": [
      "struct UF{",
      "  vector<int> par,sizes;",
      "  int cnt;",
      "  UF(int N) : par(N),sizes(N, 1),cnt(N){ for(int i=0; i<N; i++) par[i]=i; }",
      "",
      "  int find(int x){ return par[x]==x ? x : par[x] = find(par[x]); }",
      "",
      "  bool same(int x,int y){ return find(x) == find(y); }",
      "",
      "  int size(int x){ return sizes[find(x)]; }",
      "",
      "  void unite(int x, int y){",
      "    x = find(x); y = find(y);",
      "    if(x == y) return;",
      "    if(sizes[x] < sizes[y]) swap(x,y);",
      "    par[y] = x;",
      "    sizes[x] += sizes[y];",
      "    cnt--;",
      "  }",
      "  ",
      "  int count() const{return cnt;}",
      "};",
      "",
      "template<typename T>",
      "T kruskal(int N,Edges<T> &es){",
      "  sort(begin(es) , end(es) , [&](edge<T> a,edge<T> b){",
      "    return a.cost < b.cost;",
      "  });",
      "  UF uf(N);",
      "  T ret = 0;",
      "  for(edge<T> &e : es){",
      "    if(uf.same(e.src , e.to)) continue;",
      "    ret += e.cost;",
      "    uf.unite(e.src , e.to);",
      "  }",
      "  return ret;",
      "}"
    ],
    "description": "_kruskal's_algorithm"
  },
  "Cumulative_Sum_2D": {
    "prefix": "_2Druiseki",
    "body": [
      "// buildでの構築を忘れない！",
      "template< class T >",
      "struct CumulativeSum2D {",
      "  vector< vector< T > > data;",
      "",
      "  CumulativeSum2D(int H, int W) : data(H + 2, vector< int >(W + 2, 0)) {}",
      "",
      "  void add(int i, int j, T z) {",
      "    ++i, ++j;",
      "    if(i >= (int)data.size() || j >= (int)data[0].size()) return;",
      "    data[i][j] += z;",
      "  }",
      "",
      "  void build() {",
      "    for(int i = 1; i < (int)data.size(); i++) {",
      "      for(int j = 1; j < (int)data[i].size(); j++) {",
      "        data[i][j] += data[i][j - 1] + data[i - 1][j] - data[i - 1][j - 1];",
      "      }",
      "    }",
      "  }",
      "",
      "  T query(int i1, int j1, int i2, int j2) {",
      "    return (data[i2][j2] - data[i1][j2] - data[i2][j1] + data[i1][j1]);",
      "  }",
      "};"
    ],
    "description": "Cumulative_Sum_2D"
  },
  "semiring": {
    "prefix": "_semiring",
    "body": [
      "template <typename T, typename F, typename G>",
      "struct semiring {",
      "  T x;",
      "  static T id0, id1;",
      "  static F add;",
      "  static G mul;",
      "  semiring() : x(id0) {}",
      "  semiring(T y) : x(y) {}",
      "",
      "  semiring &operator+=(const semiring &p) {",
      "    if (x == id0) return *this = p;",
      "    if (p == id0) return *this;",
      "    return *this = add(x, p.x);",
      "  }",
      "",
      "  semiring &operator*=(const semiring &p) {",
      "    if (x == id0 || p == id0) return *this = id0;",
      "    if (x == id1) return *this = p;",
      "    if (p == id1) return *this;",
      "    return *this = mul(x, p.x);",
      "  }",
      "",
      "  semiring operator+(const semiring &p) const { return semiring(*this) += p; }",
      "",
      "  semiring operator*(const semiring &p) const { return semiring(*this) *= p; }",
      "",
      "  bool operator==(const semiring &p) const { return x == p.x; }",
      "",
      "  bool operator!=(const semiring &p) const { return x != p.x; }",
      "",
      "  friend ostream &operator<<(ostream &os, const semiring &p) {",
      "    return os << p.x;",
      "  }",
      "};",
      "",
      "template <typename T, typename F, typename G, int N>",
      "struct Mat {",
      "  using rig = semiring<T, F, G>;",
      "  using Array = array<array<rig, N>, N>;",
      "  Array A;",
      "  Mat() {",
      "    for (int i = 0; i < N; i++) A[i].fill(rig::id0);",
      "  }",
      "  int height() const { return N; }",
      "",
      "  int width() const { return N; }",
      "",
      "  inline const array<rig, N> &operator[](int k) const { return A[k]; }",
      "",
      "  inline array<rig, N> &operator[](int k) { return A[k]; }",
      "",
      "  static Mat I() {",
      "    Mat m;",
      "    for (int i = 0; i < N; i++) m[i][i] = rig::id1;",
      "    return (m);",
      "  }",
      "",
      "  Mat &operator+=(const Mat &B) {",
      "    for (int i = 0; i < N; i++)",
      "      for (int j = 0; j < N; j++) A[i][j] += B[i][j];",
      "    return (*this);",
      "  }",
      "",
      "  Mat &operator*=(const Mat &B) {",
      "    Mat C;",
      "    for (int i = 0; i < N; i++)",
      "      for (int j = 0; j < N; j++)",
      "        for (int k = 0; k < N; k++) C[i][j] = (C[i][j] + A[i][k] * B[k][j]);",
      "    A.swap(C.A);",
      "    return (*this);",
      "  }",
      "",
      "  Mat &operator^=(long long k) {",
      "    Mat B = Mat::I();",
      "    while (k > 0) {",
      "      if (k & 1) B *= *this;",
      "      *this *= *this;",
      "      k >>= 1LL;",
      "    }",
      "    A.swap(B.A);",
      "    return (*this);",
      "  }",
      "",
      "  Mat operator+(const Mat &B) const { return (Mat(*this) += B); }",
      "",
      "  Mat operator*(const Mat &B) const { return (Mat(*this) *= B); }",
      "",
      "  Mat operator^(const long long k) const { return (Mat(*this) ^= k); }",
      "};",
      "",
      "// old version (using std::vector)",
      "/*",
      "template <typename T, typename F, typename G>",
      "struct Mat {",
      "  using rig = semiring<T, F, G>;",
      "  vector<vector<rig> > A;",
      "  Mat() {}",
      "  Mat(int n, int m) : A(n, vector<rig>(m, rig::id0)) {}",
      "  Mat(int n) : A(n, vector<rig>(n, rig::id0)){};",
      "",
      "  int height() const { return (A.size()); }",
      "",
      "  int width() const { return (A[0].size()); }",
      "",
      "  inline const vector<rig> &operator[](int k) const { return (A.at(k)); }",
      "",
      "  inline vector<rig> &operator[](int k) { return (A.at(k)); }",
      "",
      "  static Mat I(int n) {",
      "    Mat m(n);",
      "    for (int i = 0; i < n; i++) m[i][i] = rig::id1;",
      "    return (m);",
      "  }",
      "",
      "  Mat &operator+=(const Mat &B) {",
      "    int n = height(), m = width();",
      "    assert(n == B.height() && m == B.width());",
      "    for (int i = 0; i < n; i++)",
      "      for (int j = 0; j < m; j++) (*this)[i][j] += B[i][j];",
      "    return (*this);",
      "  }",
      "",
      "  Mat &operator*=(const Mat &B) {",
      "    int n = height(), m = B.width(), p = width();",
      "    assert(p == B.height());",
      "    vector<vector<rig> > C(n, vector<rig>(m, rig::id0));",
      "    for (int i = 0; i < n; i++)",
      "      for (int j = 0; j < m; j++)",
      "        for (int k = 0; k < p; k++)",
      "          C[i][j] = (C[i][j] + (*this)[i][k] * B[k][j]);",
      "    A.swap(C);",
      "    return (*this);",
      "  }",
      "",
      "  Mat &operator^=(long long k) {",
      "    Mat B = Mat::I(height());",
      "    while (k > 0) {",
      "      if (k & 1) B *= *this;",
      "      *this *= *this;",
      "      k >>= 1LL;",
      "    }",
      "    A.swap(B.A);",
      "    return (*this);",
      "  }",
      "",
      "  Mat operator+(const Mat &B) const { return (Mat(*this) += B); }",
      "",
      "  Mat operator*(const Mat &B) const { return (Mat(*this) *= B); }",
      "",
      "  Mat operator^(const long long k) const { return (Mat(*this) ^= k); }",
      "};",
      "*/",
      "",
      "// max-plus semiring",
      "/**/",
      "using U = ll;",
      "U ID0 = -infLL;",
      "U ID1 = 0;",
      "auto Add = [](U a, U b) -> U { return max(a, b); };",
      "auto Mul = [](U a, U b) -> U { return a + b; };",
      "//*/",
      "",
      "// min-plus semiring",
      "/**",
      "using U = ll;",
      "U ID0 = infLL;",
      "U ID1 = 0;",
      "auto Add = [](U a, U b) -> U { return min(a, b); };",
      "auto Mul = [](U a, U b) -> U { return a + b; };",
      "//*/",
      "",
      "// xor-and semiring",
      "/**",
      "using U = unsigned long long;",
      "constexpr U ID0 = 0;",
      "constexpr U ID1 = 0xFFFFFFFFuLL;",
      "auto Add = [](U a, U b) -> U { return a ^ b; };",
      "auto Mul = [](U a, U b) -> U { return a & b; };",
      "//*/",
      "",
      "template <typename T, typename F, typename G>",
      "T semiring<T, F, G>::id0 = ID0;",
      "template <typename T, typename F, typename G>",
      "T semiring<T, F, G>::id1 = ID1;",
      "template <typename T, typename F, typename G>",
      "F semiring<T, F, G>::add = Add;",
      "template <typename T, typename F, typename G>",
      "G semiring<T, F, G>::mul = Mul;",
      "using rig = semiring<U, decltype(Add), decltype(Mul)>;",
      "template <int N>",
      "using mat = Mat<U, decltype(Add), decltype(Mul), N>;"
    ],
    "description": "semiring"
  },
  "Matrix_using_std::array": {
    "prefix": "_matrix_fast",
    "body": [
      "template <class T, int H, int W>",
      "struct Matrix {",
      "  using Array = array<array<T, W>, H>;",
      "  Array A;",
      "",
      "  Matrix() : A({}) {}",
      "",
      "  int height() const { return H; }",
      "",
      "  int width() const { return W; }",
      "",
      "  inline const array<T, W> &operator[](int k) const { return A[k]; }",
      "",
      "  inline array<T, W> &operator[](int k) { return A[k]; }",
      "",
      "  static Matrix I() {",
      "    assert(H == W);",
      "    Matrix mat;",
      "    for (int i = 0; i < H; i++) mat[i][i] = 1;",
      "    return (mat);",
      "  }",
      "",
      "  Matrix &operator+=(const Matrix &B) {",
      "    for (int i = 0; i < H; i++)",
      "      for (int j = 0; j < W; j++) A[i][j] += B[i][j];",
      "    return (*this);",
      "  }",
      "",
      "  Matrix &operator-=(const Matrix &B) {",
      "    for (int i = 0; i < H; i++)",
      "      for (int j = 0; j < W; j++) A[i][j] -= B[i][j];",
      "    return (*this);",
      "  }",
      "",
      "  Matrix &operator*=(const Matrix &B) {",
      "    assert(H == W);",
      "    Matrix C;",
      "    for (int i = 0; i < H; i++)",
      "      for (int j = 0; j < H; j++)",
      "        for (int k = 0; k < H; k++)",
      "          C[i][j] = (C[i][j] + A[i][k] * B[k][j]);",
      "    A.swap(C.A);",
      "    return (*this);",
      "  }",
      "",
      "  Matrix &operator^=(long long k) {",
      "    Matrix B = Matrix::I();",
      "    while (k > 0) {",
      "      if (k & 1) B *= *this;",
      "      *this *= *this;",
      "      k >>= 1LL;",
      "    }",
      "    A.swap(B.A);",
      "    return (*this);",
      "  }",
      "",
      "  Matrix operator+(const Matrix &B) const { return (Matrix(*this) += B); }",
      "",
      "  Matrix operator-(const Matrix &B) const { return (Matrix(*this) -= B); }",
      "",
      "  Matrix operator*(const Matrix &B) const { return (Matrix(*this) *= B); }",
      "",
      "  Matrix operator^(const long long k) const { return (Matrix(*this) ^= k); }",
      "",
      "  friend ostream &operator<<(ostream &os, Matrix &p) {",
      "    for (int i = 0; i < H; i++) {",
      "      os << \"[\";",
      "      for (int j = 0; j < W; j++) {",
      "        os << p[i][j] << (j + 1 == W ? \"]\\n\" : \",\");",
      "      }",
      "    }",
      "    return (os);",
      "  }",
      "",
      "  T determinant() {",
      "    Matrix B(*this);",
      "    assert(H == W);",
      "    T ret = 1;",
      "    for (int i = 0; i < H; i++) {",
      "      int idx = -1;",
      "      for (int j = i; j < W; j++) {",
      "        if (B[j][i] != 0) idx = j;",
      "      }",
      "      if (idx == -1) return (0);",
      "      if (i != idx) {",
      "        ret *= -1;",
      "        swap(B[i], B[idx]);",
      "      }",
      "      ret *= B[i][i];",
      "      T vv = B[i][i];",
      "      for (int j = 0; j < W; j++) {",
      "        B[i][j] /= vv;",
      "      }",
      "      for (int j = i + 1; j < H; j++) {",
      "        T a = B[j][i];",
      "        for (int k = 0; k < W; k++) {",
      "          B[j][k] -= B[i][k] * a;",
      "        }",
      "      }",
      "    }",
      "    return (ret);",
      "  }",
      "};"
    ],
    "description": "Matrix_using_std::array"
  },
  "Union_Find": {
    "prefix": "_unionfind",
    "body": [
      "struct UnionFind {",
      "  vector<int> data;",
      "  UnionFind(int N) : data(N, -1) {}",
      " ",
      "  int find(int k) { return data[k] < 0 ? k : data[k] = find(data[k]); }",
      " ",
      "  int unite(int x, int y) {",
      "    if ((x = find(x)) == (y = find(y))) return false;",
      "    if (data[x] > data[y]) swap(x, y);",
      "    data[x] += data[y];",
      "    data[y] = x;",
      "    return true;",
      "  }",
      " ",
      "  int size(int k) { return -data[find(k)]; }",
      " ",
      "  int same(int x, int y) { return find(x) == find(y); }",
      "};"
    ],
    "description": "Union_Find"
  },
  "Subsequence_DP": {
    "prefix": "_subsequence_dp",
    "body": [
      "vector<vector<int> > calc(const string &S) {",
      "  int n = (int)S.size();",
      "  vector<vector<int> > res(n + 1, vector<int>(26, n));",
      "  for (int i = n - 1; i >= 0; --i) {",
      "    for (int j = 0; j < 26; ++j) res[i][j] = res[i + 1][j];",
      "    res[i][S[i] - 'a'] = i;",
      "  }",
      "  return res;",
      "}"
    ],
    "description": "Subsequence_DP"
  },
  "Strongly_Connected_Components": {
    "prefix": "_strongly_connected_components",
    "body": [
      "// Strongly Connected Components",
      "// initialize        ... StronglyConnectedComponents scc(g);",
      "// build             ... vvi h; scc.build(h);",
      "// new node of k     ... scc[k]",
      "// inv of scc[k] = i ... scc.belong(i)",
      "",
      "template <typename G>",
      "struct StronglyConnectedComponents {",
      "  const G &g;",
      "  vector<vector<int>> rg;",
      "  vector<int> comp, order;",
      "  vector<char> used;",
      "  vector<vector<int>> blng;",
      "",
      "  StronglyConnectedComponents(G &g) : g(g), used(g.size(), 0) {}",
      "",
      "  int operator[](int k) { return comp[k]; }",
      "",
      "  vector<int> &belong(int i) { return blng[i]; }",
      "",
      "  void dfs(int idx) {",
      "    if (used[idx]) return;",
      "    used[idx] = true;",
      "    for (auto to : g[idx]) dfs(int(to));",
      "    order.push_back(idx);",
      "  }",
      "",
      "  void rdfs(int idx, int cnt) {",
      "    if (comp[idx] != -1) return;",
      "    comp[idx] = cnt;",
      "    for (int to : rg[idx]) rdfs(to, cnt);",
      "  }",
      "",
      "  void build(vector<vector<int>> &t) {",
      "    for (int i = 0; i < (int)g.size(); i++) dfs(i);",
      "    reverse(begin(order), end(order));",
      "    used.clear();",
      "    used.shrink_to_fit();",
      "",
      "    comp.resize(g.size(), -1);",
      "",
      "    rg.resize(g.size());",
      "    for (int i = 0; i < (int)g.size(); i++) {",
      "      for (auto e : g[i]) {",
      "        rg[(int)e].emplace_back(i);",
      "      }",
      "    }",
      "    int ptr = 0;",
      "    for (int i : order)",
      "      if (comp[i] == -1) rdfs(i, ptr), ptr++;",
      "    rg.clear();",
      "    rg.shrink_to_fit();",
      "    order.clear();",
      "    order.shrink_to_fit();",
      "",
      "    t.resize(ptr);",
      "    blng.resize(ptr);",
      "    for (int i = 0; i < (int)g.size(); i++) {",
      "      blng[comp[i]].push_back(i);",
      "      for (auto &to : g[i]) {",
      "        int x = comp[i], y = comp[to];",
      "        if (x == y) continue;",
      "        t[x].push_back(y);",
      "      }",
      "    }",
      "  }",
      "};",
      ""
    ],
    "description": "Strongly_Connected_Components"
  },
  "Grundy_Number": {
    "prefix": "_Grundy_Number",
    "body": [
      "template<typename T>",
      "vector<int> TopologicalSort(T &g){",
      "  int N = g.size();",
      "  vector<int> marked(N , 0) , temp(N , 0) , v;",
      "  auto visit = [&](auto f, int i) -> bool{",
      "    if(temp[i] == 1) return false;",
      "    if(marked[i] == 0){",
      "      temp[i] = 1;",
      "      for(auto &e : g[i]){",
      "        if(f(f , e) == false) return false;",
      "      }",
      "      marked[i] = 1;",
      "      v.push_back(i);",
      "      temp[i] = 0;",
      "    }",
      "    return true;",
      "  };",
      "  for(int i = 0 ; i < N ; i++){",
      "    if(marked[i] == 0) {",
      "      if(visit(visit , i) == false) return vector<int>();",
      "    }",
      "  }",
      "  reverse( v.begin() , v.end() );",
      "  return v;",
      "}",
      "",
      "vector<int> GrundyNumber(vector<vector<int>> &g){",
      "  vector<int> topo = TopologicalSort(g);",
      "  if((int)topo.size() == 0) return vector<int>();",
      "  vector<int> grundy(g.size() , 0);",
      "  vector<int> memo(g.size() + 1 , 0);",
      "  for(int _ = (int)g.size() - 1; _ >= 0 ; _--){",
      "    int i = topo[_];",
      "    if(g[i].size() == 0) continue;",
      "    for(auto &x : g[i]){",
      "      memo[grundy[x]]++;",
      "    }",
      "    while(memo[grundy[i]] > 0) grundy[i]++;",
      "    for(auto &x : g[i]){",
      "      memo[grundy[x]]--;",
      "    }",
      "  }",
      "  return grundy;",
      "};"
    ],
    "description": "Grundy_Number"
  },
  "solve_function_for_multitest": {
    "prefix": "_solve_for_multitest",
    "body": [
      "void q(){",
      "  $0",
      "}",
      "",
      "void solve(){",
      "  int T;",
      "  cin >> T;",
      "  for(int i = 0 ; i < T ; i++) q();",
      "}"
    ],
    "description": "solve_function_for_multitest"
  },
  "Rerooting": {
    "prefix": "_rerooting",
    "body": [
      "// Rerooting",
      "// f1(c1, c2) ... merge value of child node",
      "// f2(memo[i] , i) ... return value to parent node",
      "// memo[i] ... result of subtree rooted i",
      "// dp[i] ... result of tree rooted i",
      "",
      "template <typename T, typename G, typename F1, typename F2>",
      "struct Rerooting {",
      "  const G &g;",
      "  const F1 f1;",
      "  const F2 f2;",
      "  vector<T> memo, dp;",
      "  T I;",
      "",
      "  Rerooting(const G &g, const F1 f1, const F2 f2, const T &I)",
      "      : g(g), f1(f1), f2(f2), memo(g.size(), I), dp(g.size(), I), I(I) {",
      "    dfs(0, -1);",
      "    efs(0, -1, I);",
      "  }",
      "",
      "  const T &operator[](int i) const { return dp[i]; }",
      "",
      "  void dfs(int cur, int par) {",
      "    for (auto &dst : g[cur]) {",
      "      if (dst == par) continue;",
      "      dfs(dst, cur);",
      "      memo[cur] = f1(memo[cur], f2(memo[dst], dst));",
      "    }",
      "  }",
      "",
      "  void efs(int cur, int par, const T &pval) {",
      "    // get cumulative sum",
      "    vector<T> buf;",
      "    for (auto dst : g[cur]) {",
      "      if (dst == par) continue;",
      "      buf.push_back(f2(memo[dst], dst));",
      "    }",
      "    vector<T> head(buf.size() + 1), tail(buf.size() + 1);",
      "    head[0] = tail[buf.size()] = I;",
      "    for (int i = 0; i < (int)buf.size(); i++) head[i + 1] = f1(head[i], buf[i]);",
      "    for (int i = (int)buf.size() - 1; i >= 0; i--)",
      "      tail[i] = f1(tail[i + 1], buf[i]);",
      "",
      "    // update",
      "    dp[cur] = par == -1 ? head.back() : f1(pval, head.back());",
      "",
      "    // propagate",
      "    int idx = 0;",
      "    for (auto &dst : g[cur]) {",
      "      if (dst == par) continue;",
      "      efs(dst, cur, f2(f1(pval, f1(head[idx], tail[idx + 1])), cur));",
      "      idx++;",
      "    }",
      "  }",
      "};",
      "",
      "/*",
      "",
      "using T = ;",
      "// identify element of f1, and answer of leaf",
      "T I = ;",
      "// merge value of child node",
      "auto f1 = [&](T x, T y) -> T {",
      "",
      "};",
      "// return value to parent node",
      "auto f2 = [&](T x, int i) -> T {",
      "",
      "};",
      "Rerooting<T, decltype(g), decltype(f1), decltype(f2)> dp(g, f1, f2, I);",
      "",
      "*/"
    ],
    "description": "Rerooting"
  },
  "Heavy_Light_Decomposition": {
    "prefix": "_heavylightdecomposition",
    "body": [
      "template <typename G = vector<vector<int> > >",
      "struct HeavyLightDecomposition {",
      "  G& g;",
      "  int idx;",
      "  vector<int> size, depth, in, out, nxt, par;",
      "  HeavyLightDecomposition(G& g, int root = 0)",
      "      : g(g),",
      "        idx(0),",
      "        size(g.size(), 0),",
      "        depth(g.size(), 0),",
      "        in(g.size(), -1),",
      "        out(g.size(), -1),",
      "        nxt(g.size(), 0),",
      "        par(g.size(), root) {",
      "    dfs_sz(root);",
      "    dfs_hld(root);",
      "  }",
      "",
      "  void build(int root) {",
      "    dfs_sz(root);",
      "    dfs_hld(root);",
      "  }",
      "",
      "  void dfs_sz(int cur) {",
      "    size[cur] = 1;",
      "    for (auto& dst : g[cur]) {",
      "      if (dst == par[cur]) {",
      "        if (g[cur].size() >= 2 && int(dst) == int(g[cur][0]))",
      "          swap(g[cur][0], g[cur][1]);",
      "        else",
      "          continue;",
      "      }",
      "      depth[dst] = depth[cur] + 1;",
      "      par[dst] = cur;",
      "      dfs_sz(dst);",
      "      size[cur] += size[dst];",
      "      if (size[dst] > size[g[cur][0]]) {",
      "        swap(dst, g[cur][0]);",
      "      }",
      "    }",
      "  }",
      "",
      "  void dfs_hld(int cur) {",
      "    in[cur] = idx++;",
      "    for (auto dst : g[cur]) {",
      "      if (dst == par[cur]) continue;",
      "      nxt[dst] = (int(dst) == int(g[cur][0]) ? nxt[cur] : int(dst));",
      "      dfs_hld(dst);",
      "    }",
      "    out[cur] = idx;",
      "  }",
      "",
      "  template <typename F>",
      "  void edge_query(int u, int v, const F& f) {",
      "    while (1) {",
      "      if (in[u] > in[v]) swap(u, v);",
      "      if (nxt[u] != nxt[v]) {",
      "        f(in[nxt[v]], in[v] + 1);",
      "        v = par[nxt[v]];",
      "      } else {",
      "        if (u != v) f(in[u] + 1, in[v] + 1);",
      "        break;",
      "      }",
      "    }",
      "  }",
      "",
      "  template <typename F>",
      "  void node_query(int u, int v, const F& f) {",
      "    while (1) {",
      "      if (in[u] > in[v]) swap(u, v);",
      "      if (nxt[u] != nxt[v]) {",
      "        f(in[nxt[v]], in[v] + 1);",
      "        v = par[nxt[v]];",
      "      } else {",
      "        f(in[u], in[v] + 1);",
      "        break;",
      "      }",
      "    }",
      "  }",
      "",
      "  template <typename F>",
      "  void sub_edge_query(int u, const F& f) {",
      "    f(in[u] + 1, out[u]);",
      "  }",
      "",
      "  template <typename F>",
      "  void sub_node_query(int u, const F& f) {",
      "    f(in[u], out[u]);",
      "  }",
      "",
      "  int lca(int a, int b) {",
      "    while (nxt[a] != nxt[b]) {",
      "      if (in[a] < in[b]) swap(a, b);",
      "      a = par[nxt[a]];",
      "    }",
      "    return depth[a] < depth[b] ? a : b;",
      "  }",
      "};"
    ],
    "description": "Heavy_Light_Decomposition"
  },
  "gray_code": {
    "prefix": "_gray_code",
    "body": [
      "vector<int> gray_code(int n){",
      "  if(n == 1) return vi{0 , 1};",
      "  vi ret = gray_code(n - 1);",
      "  vi inv = ret;",
      "  reverse(all(inv));",
      "  each(x , inv) x |= 1 << (n - 1);",
      "  copy(all(inv), back_inserter(ret));",
      "  return ret;",
      "};"
    ],
    "description": "gray_code"
  },
  "Range_Add_Range_Sum_LazySegTree": {
    "prefix": "_lazyseg_add_sum",
    "body": [
      "template <typename E>",
      "struct AddSum_LazySegmentTree {",
      "  int n, height;",
      "  using T = pair<E, E>;",
      "  T f(T a, T b) { return T(a.first + b.first, a.second + b.second); };",
      "  T g(T a, E b) { return T(a.first + b * a.second, a.second); };",
      "  E h(E a, E b) { return a + b; };",
      "  T ti = P(0, 0);",
      "  E ei = 0;",
      "  vector<T> dat;",
      "  vector<E> laz;",
      "",
      "  AddSum_LazySegmentTree(const vector<E> &v) { build(v); }",
      "",
      "  void init(int n_) {",
      "    n = 1;",
      "    height = 0;",
      "    while (n < n_) n <<= 1, height++;",
      "    dat.assign(2 * n, ti);",
      "    laz.assign(2 * n, ei);",
      "  }",
      "",
      "  void build(const vector<E> &v) {",
      "    int n_ = v.size();",
      "    init(n_);",
      "    for (int i = 0; i < n_; i++) dat[n + i] = T(v[i], 1);",
      "    for (int i = n - 1; i; i--)",
      "      dat[i] = f(dat[(i << 1) | 0], dat[(i << 1) | 1]);",
      "  }",
      "",
      "  inline T reflect(int k) { return laz[k] == ei ? dat[k] : g(dat[k], laz[k]); }",
      "",
      "  inline void propagate(int k) {",
      "    if (laz[k] == ei) return;",
      "    laz[(k << 1) | 0] = h(laz[(k << 1) | 0], laz[k]);",
      "    laz[(k << 1) | 1] = h(laz[(k << 1) | 1], laz[k]);",
      "    dat[k] = reflect(k);",
      "    laz[k] = ei;",
      "  }",
      "",
      "  inline void thrust(int k) {",
      "    for (int i = height; i; i--) propagate(k >> i);",
      "  }",
      "",
      "  inline void recalc(int k) {",
      "    while (k >>= 1) dat[k] = f(reflect((k << 1) | 0), reflect((k << 1) | 1));",
      "  }",
      "",
      "  void update(int a, int b, E x) {",
      "    if (a >= b) return;",
      "    thrust(a += n);",
      "    thrust(b += n - 1);",
      "    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
      "      if (l & 1) laz[l] = h(laz[l], x), l++;",
      "      if (r & 1) --r, laz[r] = h(laz[r], x);",
      "    }",
      "    recalc(a);",
      "    recalc(b);",
      "  }",
      "",
      "  void set_val(int a, T x) {",
      "    thrust(a += n);",
      "    dat[a] = x;",
      "    laz[a] = ei;",
      "    recalc(a);",
      "  }",
      "",
      "  E query(int a, int b) {",
      "    if (a >= b) return ti.first;",
      "    thrust(a += n);",
      "    thrust(b += n - 1);",
      "    T vl = ti, vr = ti;",
      "    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
      "      if (l & 1) vl = f(vl, reflect(l++));",
      "      if (r & 1) vr = f(reflect(--r), vr);",
      "    }",
      "    return f(vl, vr).first;",
      "  }",
      "};"
    ],
    "description": "Range_Add_Range_Sum_LazySegTree"
  },
  "Range_Update_Range_Sum_LazySegTree": {
    "prefix": "_lazyseg_update_sum",
    "body": [
      "template <typename E, E INF>",
      "struct UpdateSum_LazySegmentTree {",
      "  int n, height;",
      "  using T = pair<E, E>;",
      "  T f(T a, T b) { return T(a.first + b.first, a.second + b.second); };",
      "  T g(T a, E b) { return T(b * a.second, a.second); };",
      "  E h(E a, E b) { return b; };",
      "  T ti = P(0, 0);",
      "  E ei = INF;",
      "  vector<T> dat;",
      "  vector<E> laz;",
      "",
      "  UpdateSum_LazySegmentTree(const vector<E> &v) { build(v); }",
      "",
      "  void init(int n_) {",
      "    n = 1;",
      "    height = 0;",
      "    while (n < n_) n <<= 1, height++;",
      "    dat.assign(2 * n, ti);",
      "    laz.assign(2 * n, ei);",
      "  }",
      "",
      "  void build(const vector<E> &v) {",
      "    int n_ = v.size();",
      "    init(n_);",
      "    for (int i = 0; i < n_; i++) dat[n + i] = T(v[i], 1);",
      "    for (int i = n - 1; i; i--)",
      "      dat[i] = f(dat[(i << 1) | 0], dat[(i << 1) | 1]);",
      "  }",
      "",
      "  inline T reflect(int k) { return laz[k] == ei ? dat[k] : g(dat[k], laz[k]); }",
      "",
      "  inline void propagate(int k) {",
      "    if (laz[k] == ei) return;",
      "    laz[(k << 1) | 0] = h(laz[(k << 1) | 0], laz[k]);",
      "    laz[(k << 1) | 1] = h(laz[(k << 1) | 1], laz[k]);",
      "    dat[k] = reflect(k);",
      "    laz[k] = ei;",
      "  }",
      "",
      "  inline void thrust(int k) {",
      "    for (int i = height; i; i--) propagate(k >> i);",
      "  }",
      "",
      "  inline void recalc(int k) {",
      "    while (k >>= 1) dat[k] = f(reflect((k << 1) | 0), reflect((k << 1) | 1));",
      "  }",
      "",
      "  void update(int a, int b, E x) {",
      "    if (a >= b) return;",
      "    thrust(a += n);",
      "    thrust(b += n - 1);",
      "    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
      "      if (l & 1) laz[l] = h(laz[l], x), l++;",
      "      if (r & 1) --r, laz[r] = h(laz[r], x);",
      "    }",
      "    recalc(a);",
      "    recalc(b);",
      "  }",
      "",
      "  void set_val(int a, T x) {",
      "    thrust(a += n);",
      "    dat[a] = x;",
      "    laz[a] = ei;",
      "    recalc(a);",
      "  }",
      "",
      "  E query(int a, int b) {",
      "    if (a >= b) return ti.first;",
      "    thrust(a += n);",
      "    thrust(b += n - 1);",
      "    T vl = ti, vr = ti;",
      "    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
      "      if (l & 1) vl = f(vl, reflect(l++));",
      "      if (r & 1) vr = f(reflect(--r), vr);",
      "    }",
      "    return f(vl, vr).first;",
      "  }",
      "};"
    ],
    "description": "Range_Update_Range_Sum_LazySegTree"
  },
  "Range_Update_Range_Minimum_LazySegTree": {
    "prefix": "_lazyseg_update_min",
    "body": [
      "template <typename E, E INF>",
      "struct UpdateMin_LazySegmentTree {",
      "  int n, height;",
      "  using T = E;",
      "  T f(T a, T b) { return min(a, b); };",
      "  T g(T a, E b) { return b; };",
      "  E h(E a, E b) { return b; };",
      "  T ti = INF;",
      "  E ei = INF;",
      "  vector<T> dat;",
      "  vector<E> laz;",
      "",
      "  UpdateMin_LazySegmentTree(const vector<E> &v) { build(v); }",
      "",
      "  void init(int n_) {",
      "    n = 1;",
      "    height = 0;",
      "    while (n < n_) n <<= 1, height++;",
      "    dat.assign(2 * n, ti);",
      "    laz.assign(2 * n, ei);",
      "  }",
      "",
      "  void build(const vector<E> &v) {",
      "    int n_ = v.size();",
      "    init(n_);",
      "    for (int i = 0; i < n_; i++) dat[n + i] = v[i];",
      "    for (int i = n - 1; i; i--)",
      "      dat[i] = f(dat[(i << 1) | 0], dat[(i << 1) | 1]);",
      "  }",
      "",
      "  inline T reflect(int k) { return laz[k] == ei ? dat[k] : g(dat[k], laz[k]); }",
      "",
      "  inline void propagate(int k) {",
      "    if (laz[k] == ei) return;",
      "    laz[(k << 1) | 0] = h(laz[(k << 1) | 0], laz[k]);",
      "    laz[(k << 1) | 1] = h(laz[(k << 1) | 1], laz[k]);",
      "    dat[k] = reflect(k);",
      "    laz[k] = ei;",
      "  }",
      "",
      "  inline void thrust(int k) {",
      "    for (int i = height; i; i--) propagate(k >> i);",
      "  }",
      "",
      "  inline void recalc(int k) {",
      "    while (k >>= 1) dat[k] = f(reflect((k << 1) | 0), reflect((k << 1) | 1));",
      "  }",
      "",
      "  void update(int a, int b, E x) {",
      "    if (a >= b) return;",
      "    thrust(a += n);",
      "    thrust(b += n - 1);",
      "    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
      "      if (l & 1) laz[l] = h(laz[l], x), l++;",
      "      if (r & 1) --r, laz[r] = h(laz[r], x);",
      "    }",
      "    recalc(a);",
      "    recalc(b);",
      "  }",
      "",
      "  void set_val(int a, T x) {",
      "    thrust(a += n);",
      "    dat[a] = x;",
      "    laz[a] = ei;",
      "    recalc(a);",
      "  }",
      "",
      "  T query(int a, int b) {",
      "    if (a >= b) return ti;",
      "    thrust(a += n);",
      "    thrust(b += n - 1);",
      "    T vl = ti, vr = ti;",
      "    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
      "      if (l & 1) vl = f(vl, reflect(l++));",
      "      if (r & 1) vr = f(reflect(--r), vr);",
      "    }",
      "    return f(vl, vr);",
      "  }",
      "};"
    ],
    "description": "Range_Update_Range_Minimum_LazySegTree"
  },
  "Range_Update_Range_Maximum_LazySegTree": {
    "prefix": "_lazyseg_update_max",
    "body": [
      "template <typename E, E MINF>",
      "struct UpdateMax_LazySegmentTree {",
      "  int n, height;",
      "  using T = E;",
      "  T f(T a, T b) { return max(a, b); };",
      "  T g(T a, E b) { return b; };",
      "  E h(E a, E b) { return b; };",
      "  T ti = MINF;",
      "  E ei = MINF;",
      "  vector<T> dat;",
      "  vector<E> laz;",
      "",
      "  UpdateMax_LazySegmentTree(const vector<E> &v) { build(v); }",
      "",
      "  void init(int n_) {",
      "    n = 1;",
      "    height = 0;",
      "    while (n < n_) n <<= 1, height++;",
      "    dat.assign(2 * n, ti);",
      "    laz.assign(2 * n, ei);",
      "  }",
      "",
      "  void build(const vector<E> &v) {",
      "    int n_ = v.size();",
      "    init(n_);",
      "    for (int i = 0; i < n_; i++) dat[n + i] = v[i];",
      "    for (int i = n - 1; i; i--)",
      "      dat[i] = f(dat[(i << 1) | 0], dat[(i << 1) | 1]);",
      "  }",
      "",
      "  inline T reflect(int k) { return laz[k] == ei ? dat[k] : g(dat[k], laz[k]); }",
      "",
      "  inline void propagate(int k) {",
      "    if (laz[k] == ei) return;",
      "    laz[(k << 1) | 0] = h(laz[(k << 1) | 0], laz[k]);",
      "    laz[(k << 1) | 1] = h(laz[(k << 1) | 1], laz[k]);",
      "    dat[k] = reflect(k);",
      "    laz[k] = ei;",
      "  }",
      "",
      "  inline void thrust(int k) {",
      "    for (int i = height; i; i--) propagate(k >> i);",
      "  }",
      "",
      "  inline void recalc(int k) {",
      "    while (k >>= 1) dat[k] = f(reflect((k << 1) | 0), reflect((k << 1) | 1));",
      "  }",
      "",
      "  void update(int a, int b, E x) {",
      "    if (a >= b) return;",
      "    thrust(a += n);",
      "    thrust(b += n - 1);",
      "    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
      "      if (l & 1) laz[l] = h(laz[l], x), l++;",
      "      if (r & 1) --r, laz[r] = h(laz[r], x);",
      "    }",
      "    recalc(a);",
      "    recalc(b);",
      "  }",
      "",
      "  void set_val(int a, T x) {",
      "    thrust(a += n);",
      "    dat[a] = x;",
      "    laz[a] = ei;",
      "    recalc(a);",
      "  }",
      "",
      "  T query(int a, int b) {",
      "    if (a >= b) return ti;",
      "    thrust(a += n);",
      "    thrust(b += n - 1);",
      "    T vl = ti, vr = ti;",
      "    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
      "      if (l & 1) vl = f(vl, reflect(l++));",
      "      if (r & 1) vr = f(reflect(--r), vr);",
      "    }",
      "    return f(vl, vr);",
      "  }",
      "};"
    ],
    "description": "Range_Update_Range_Maximum_LazySegTree"
  },
  "Range_Add_Range_Minimum_LazySegTree": {
    "prefix": "_lazyseg_add_min",
    "body": [
      "template <typename E, E INF>",
      "struct AddMin_LazySegmentTree {",
      "  int n, height;",
      "  using T = E;",
      "  T f(T a, T b) { return min(a, b); };",
      "  T g(T a, E b) { return a + b; };",
      "  E h(E a, E b) { return a + b; };",
      "  T ti = INF;",
      "  E ei = 0;",
      "  vector<T> dat;",
      "  vector<E> laz;",
      "",
      "  AddMin_LazySegmentTree(const vector<E> &v) { build(v); }",
      "",
      "  void init(int n_) {",
      "    n = 1;",
      "    height = 0;",
      "    while (n < n_) n <<= 1, height++;",
      "    dat.assign(2 * n, ti);",
      "    laz.assign(2 * n, ei);",
      "  }",
      "",
      "  void build(const vector<E> &v) {",
      "    int n_ = v.size();",
      "    init(n_);",
      "    for (int i = 0; i < n_; i++) dat[n + i] = v[i];",
      "    for (int i = n - 1; i; i--)",
      "      dat[i] = f(dat[(i << 1) | 0], dat[(i << 1) | 1]);",
      "  }",
      "",
      "  inline T reflect(int k) { return laz[k] == ei ? dat[k] : g(dat[k], laz[k]); }",
      "",
      "  inline void propagate(int k) {",
      "    if (laz[k] == ei) return;",
      "    laz[(k << 1) | 0] = h(laz[(k << 1) | 0], laz[k]);",
      "    laz[(k << 1) | 1] = h(laz[(k << 1) | 1], laz[k]);",
      "    dat[k] = reflect(k);",
      "    laz[k] = ei;",
      "  }",
      "",
      "  inline void thrust(int k) {",
      "    for (int i = height; i; i--) propagate(k >> i);",
      "  }",
      "",
      "  inline void recalc(int k) {",
      "    while (k >>= 1) dat[k] = f(reflect((k << 1) | 0), reflect((k << 1) | 1));",
      "  }",
      "",
      "  void update(int a, int b, E x) {",
      "    if (a >= b) return;",
      "    thrust(a += n);",
      "    thrust(b += n - 1);",
      "    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
      "      if (l & 1) laz[l] = h(laz[l], x), l++;",
      "      if (r & 1) --r, laz[r] = h(laz[r], x);",
      "    }",
      "    recalc(a);",
      "    recalc(b);",
      "  }",
      "",
      "  void set_val(int a, T x) {",
      "    thrust(a += n);",
      "    dat[a] = x;",
      "    laz[a] = ei;",
      "    recalc(a);",
      "  }",
      "",
      "  T query(int a, int b) {",
      "    if (a >= b) return ti;",
      "    thrust(a += n);",
      "    thrust(b += n - 1);",
      "    T vl = ti, vr = ti;",
      "    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
      "      if (l & 1) vl = f(vl, reflect(l++));",
      "      if (r & 1) vr = f(reflect(--r), vr);",
      "    }",
      "    return f(vl, vr);",
      "  }",
      "};"
    ],
    "description": "Range_Add_Range_Minimum_LazySegTree"
  },
  "Range_Add_Range_Maximum_LazySegTree": {
    "prefix": "_lazyseg_add_max",
    "body": [
      "template <typename E, E MINF>",
      "struct AddMax_LazySegmentTree {",
      "  int n, height;",
      "  using T = E;",
      "  T f(T a, T b) { return max(a, b); };",
      "  T g(T a, E b) { return a + b; };",
      "  E h(E a, E b) { return a + b; };",
      "  T ti = MINF;",
      "  E ei = 0;",
      "  vector<T> dat;",
      "  vector<E> laz;",
      "",
      "  AddMax_LazySegmentTree(const vector<E> &v) { build(v); }",
      "",
      "  void init(int n_) {",
      "    n = 1;",
      "    height = 0;",
      "    while (n < n_) n <<= 1, height++;",
      "    dat.assign(2 * n, ti);",
      "    laz.assign(2 * n, ei);",
      "  }",
      "",
      "  void build(const vector<E> &v) {",
      "    int n_ = v.size();",
      "    init(n_);",
      "    for (int i = 0; i < n_; i++) dat[n + i] = v[i];",
      "    for (int i = n - 1; i; i--)",
      "      dat[i] = f(dat[(i << 1) | 0], dat[(i << 1) | 1]);",
      "  }",
      "",
      "  inline T reflect(int k) { return laz[k] == ei ? dat[k] : g(dat[k], laz[k]); }",
      "",
      "  inline void propagate(int k) {",
      "    if (laz[k] == ei) return;",
      "    laz[(k << 1) | 0] = h(laz[(k << 1) | 0], laz[k]);",
      "    laz[(k << 1) | 1] = h(laz[(k << 1) | 1], laz[k]);",
      "    dat[k] = reflect(k);",
      "    laz[k] = ei;",
      "  }",
      "",
      "  inline void thrust(int k) {",
      "    for (int i = height; i; i--) propagate(k >> i);",
      "  }",
      "",
      "  inline void recalc(int k) {",
      "    while (k >>= 1) dat[k] = f(reflect((k << 1) | 0), reflect((k << 1) | 1));",
      "  }",
      "",
      "  void update(int a, int b, E x) {",
      "    if (a >= b) return;",
      "    thrust(a += n);",
      "    thrust(b += n - 1);",
      "    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
      "      if (l & 1) laz[l] = h(laz[l], x), l++;",
      "      if (r & 1) --r, laz[r] = h(laz[r], x);",
      "    }",
      "    recalc(a);",
      "    recalc(b);",
      "  }",
      "",
      "  void set_val(int a, T x) {",
      "    thrust(a += n);",
      "    dat[a] = x;",
      "    laz[a] = ei;",
      "    recalc(a);",
      "  }",
      "",
      "  T query(int a, int b) {",
      "    if (a >= b) return ti;",
      "    thrust(a += n);",
      "    thrust(b += n - 1);",
      "    T vl = ti, vr = ti;",
      "    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
      "      if (l & 1) vl = f(vl, reflect(l++));",
      "      if (r & 1) vr = f(reflect(--r), vr);",
      "    }",
      "    return f(vl, vr);",
      "  }",
      "};"
    ],
    "description": "Range_Add_Range_Maximum_LazySegTree"
  },
  "LazyMontgomeryModInt": {
    "prefix": "_lazy_montgomery",
    "body": [
      "static constexpr uint32_t get_r(int mod) {",
      "  uint64_t ret = 1, m = mod, n = mod - 2;",
      "  while (n) {",
      "    ret = uint32_t(ret * m);",
      "    m = uint32_t(m * m);",
      "    n >>= 1;",
      "  }",
      "  return ret;",
      "};",
      "",
      "template <uint32_t mod>",
      "struct LazyMontgomeryModInt {",
      "  using mint = LazyMontgomeryModInt;",
      "  using i32 = int32_t;",
      "  using u32 = uint32_t;",
      "  using u64 = uint64_t;",
      "",
      "  static constexpr u32 r = get_r(mod);",
      "  static constexpr u32 n2 = -u64(mod) % mod;",
      "  static_assert(r * mod == 1, \"invalid, r * mod != 1\");",
      "  static_assert(mod < (1 << 30), \"invalid, mod >= 2 ^ 30\");",
      "  static_assert((mod & 1) == 1, \"invalid, mod % 2 == 0\");",
      "",
      "  u32 a;",
      "",
      "  LazyMontgomeryModInt() : a(0) {}",
      "  LazyMontgomeryModInt(const int64_t &b) : a(reduce(u64(b % mod + mod) * n2)){};",
      "",
      "  static u32 reduce(const u64 &b) {",
      "    return u32(b >> 32) + mod - u32((u64(u32(b) * r) * mod) >> 32);",
      "  }",
      "",
      "  mint &operator+=(const mint &b) {",
      "    if (i32(a += b.a - 2 * mod) < 0) a += 2 * mod;",
      "    return *this;",
      "  }",
      "",
      "  mint &operator-=(const mint &b) {",
      "    if (i32(a -= b.a) < 0) a += 2 * mod;",
      "    return *this;",
      "  }",
      "",
      "  mint &operator*=(const mint &b) {",
      "    a = reduce(u64(a) * b.a);",
      "    return *this;",
      "  }",
      "",
      "  mint &operator/=(const mint &b) {",
      "    *this *= b.inverse();",
      "    return *this;",
      "  }",
      "",
      "  mint operator+(const mint &b) const { return mint(*this) += b; }",
      "  mint operator-(const mint &b) const { return mint(*this) -= b; }",
      "  mint operator*(const mint &b) const { return mint(*this) *= b; }",
      "  mint operator/(const mint &b) const { return mint(*this) /= b; }",
      "",
      "  u32 get() const {",
      "    u32 ret = reduce(a);",
      "    return ret >= mod ? ret - mod : ret;",
      "  }",
      "",
      "  mint pow(u64 n) const {",
      "    mint ret(1), mul(*this);",
      "    while (n > 0) {",
      "      if (n & 1) ret *= mul;",
      "      mul *= mul;",
      "      n >>= 1;",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  friend ostream &operator<<(ostream &os, const mint &b) {",
      "    return os << b.get();",
      "  }",
      "",
      "  friend istream &operator>>(istream &is, mint &b) {",
      "    int64_t t;",
      "    is >> t;",
      "    b = LazyMontgomeryModInt<mod>(t);",
      "    return (is);",
      "  }",
      "",
      "  mint inverse() const { return pow(mod - 2); }",
      "",
      "  static constexpr u32 get_mod() { return mod; }",
      "};"
    ],
    "description": "LazyMontgomeryModInt"
  },
  "Rational_Number": {
    "prefix": "_RationalNumber",
    "body": [
      "",
      "struct RationalNumber {",
      "  pair<ll, ll> a;",
      "",
      "  RationalNumber(pair<ll, ll> p) { a = init(p.first, p.second); }",
      "  RationalNumber(ll x, ll y) { a = init(x, y); }",
      "",
      "  pair<ll, ll> init(ll x, ll y) {",
      "    if (x == 0 && y == 0) return pair<ll, ll>(0, 0);",
      "    ll g = gcd(abs(x), abs(y));",
      "    x /= g;",
      "    y /= g;",
      "    if (x < 0) x = -x, y = -y;",
      "    if (x == 0 && y < 0) y = -y;",
      "    return pair<ll, ll>(x, y);",
      "  }",
      "",
      "  ll gcd(ll x, ll y) {",
      "    ll z;",
      "    if (x > y) swap(x, y);",
      "    while (x) {",
      "      x = y % (z = x);",
      "      y = z;",
      "    }",
      "    return y;",
      "  }",
      "  bool zero() const { return a.first == 0 && a.second == 0; }",
      "  RationalNumber orth() const { return RationalNumber{-a.second, a.first}; }",
      "};",
      "namespace std {",
      "bool operator<(const RationalNumber &x, const RationalNumber &y) {",
      "  return x.a < y.a;",
      "}",
      "bool operator==(const RationalNumber &x, const RationalNumber &y) {",
      "  return x.a == y.a;",
      "}",
      "bool operator!=(const RationalNumber &x, const RationalNumber &y) {",
      "  return x.a != y.a;",
      "}",
      "}  // namespace std"
    ],
    "description": "Rational_Number"
  },
  "arbitrary_modint": {
    "prefix": "_arbitrary_mint",
    "body": [
      "struct ArbitraryModInt {",
      "",
      "  int x;",
      "",
      "  ArbitraryModInt() : x(0) {}",
      "",
      "  ArbitraryModInt(int64_t y) : x(y >= 0 ? y % get_mod() : (get_mod() - (-y) % get_mod()) % get_mod()) {}",
      "",
      "  static int &get_mod() {",
      "    static int mod = 0;",
      "    return mod;",
      "  }",
      "",
      "  static void set_mod(int md) {",
      "    get_mod() = md;",
      "  }",
      "",
      "  ArbitraryModInt &operator+=(const ArbitraryModInt &p) {",
      "    if((x += p.x) >= get_mod()) x -= get_mod();",
      "    return *this;",
      "  }",
      "",
      "  ArbitraryModInt &operator-=(const ArbitraryModInt &p) {",
      "    if((x += get_mod() - p.x) >= get_mod()) x -= get_mod();",
      "    return *this;",
      "  }",
      "",
      "  ArbitraryModInt &operator*=(const ArbitraryModInt &p) {",
      "    unsigned long long a = (unsigned long long) x * p.x;",
      "    unsigned xh = (unsigned) (a >> 32), xl = (unsigned) a, d, m;",
      "    asm(\"divl %4; \\n\\t\" : \"=a\" (d), \"=d\" (m) : \"d\" (xh), \"a\" (xl), \"r\" (get_mod()));",
      "    x = m;",
      "    return *this;",
      "  }",
      "",
      "  ArbitraryModInt &operator/=(const ArbitraryModInt &p) {",
      "    *this *= p.inverse();",
      "    return *this;",
      "  }",
      "",
      "  ArbitraryModInt operator-() const { return ArbitraryModInt(-x); }",
      "",
      "  ArbitraryModInt operator+(const ArbitraryModInt &p) const { return ArbitraryModInt(*this) += p; }",
      "",
      "  ArbitraryModInt operator-(const ArbitraryModInt &p) const { return ArbitraryModInt(*this) -= p; }",
      "",
      "  ArbitraryModInt operator*(const ArbitraryModInt &p) const { return ArbitraryModInt(*this) *= p; }",
      "",
      "  ArbitraryModInt operator/(const ArbitraryModInt &p) const { return ArbitraryModInt(*this) /= p; }",
      "",
      "  bool operator==(const ArbitraryModInt &p) const { return x == p.x; }",
      "",
      "  bool operator!=(const ArbitraryModInt &p) const { return x != p.x; }",
      "",
      "  ArbitraryModInt inverse() const {",
      "    int a = x, b = get_mod(), u = 1, v = 0, t;",
      "    while(b > 0) {",
      "      t = a / b;",
      "      swap(a -= t * b, b);",
      "      swap(u -= t * v, v);",
      "    }",
      "    return ArbitraryModInt(u);",
      "  }",
      "",
      "  ArbitraryModInt pow(int64_t n) const {",
      "    ArbitraryModInt ret(1), mul(x);",
      "    while(n > 0) {",
      "      if(n & 1) ret *= mul;",
      "      mul *= mul;",
      "      n >>= 1;",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  friend ostream &operator<<(ostream &os, const ArbitraryModInt &p) {",
      "    return os << p.x;",
      "  }",
      "",
      "  friend istream &operator>>(istream &is, ArbitraryModInt &a) {",
      "    int64_t t;",
      "    is >> t;",
      "    a = ArbitraryModInt(t);",
      "    return (is);",
      "  }",
      "};",
      "",
      "using mint = ArbitraryModInt;",
      "using vm = vector<mint>;"
    ],
    "description": "arbitrary_modint"
  },
  "PersistentSegmentTree": {
    "prefix": "_persistent_segment_tree",
    "body": [
      "// if you want to reserve memory at once,",
      "// activate below line, and change type of pool properly.",
      "// #define reserve_pool_at_once",
      "",
      "template <typename T>",
      "struct _Node {",
      "  T data;",
      "  _Node *l, *r;",
      "  _Node() {}",
      "  _Node(const T &_data) : data(_data), l(nullptr), r(nullptr) {}",
      "};",
      "",
      "#ifdef reserve_pool_at_once",
      "_Node<int> pool[40000000];",
      "#endif",
      "",
      "template <typename T, typename F, int NODES = 8388608>",
      "struct PersistentSegmentTree {",
      "  using ll = long long;",
      "  using Node = _Node<T>;",
      "",
      "#ifndef reserve_pool_at_once",
      "  Node *pool;",
      "#endif",
      "  int pid;",
      "  ll N;",
      "  const F &f;",
      "  const T ID;",
      "  Node *nil;",
      "  vector<Node *> roots;",
      "",
      "  PersistentSegmentTree(const vector<T> &v, const F &_f, const T &_ID)",
      "      : pid(0), f(_f), ID(_ID), nil(nullptr) {",
      "#ifndef reserve_pool_at_once",
      "    pool = new Node[NODES];",
      "#endif",
      "    nil = my_new(ID);",
      "    nil->l = nil->r = nil;",
      "    roots.reserve(262144);",
      "    roots.push_back(build(v));",
      "  }",
      "",
      "  PersistentSegmentTree(const ll &_N, const F &_f, const T &_ID)",
      "      : pid(0), N(_N), f(_f), ID(_ID), nil(nullptr) {",
      "#ifndef reserve_pool_at_once",
      "    pool = new Node[NODES];",
      "#endif",
      "    nil = my_new(ID);",
      "    nil->l = nil->r = nil;",
      "    roots.reserve(262144);",
      "    roots.push_back(nil);",
      "  }",
      "",
      "  Node *my_new(const T &data) {",
      "    pool[pid].data = data;",
      "    pool[pid].l = pool[pid].r = nil;",
      "    return &(pool[pid++]);",
      "  }",
      "",
      "  Node *merge(Node *l, Node *r) {",
      "    pool[pid].data = f(l->data, r->data);",
      "    pool[pid].l = l;",
      "    pool[pid].r = r;",
      "    return &(pool[pid++]);",
      "  }",
      "",
      "  Node *build(const vector<T> &v) {",
      "    N = (ll)v.size();",
      "    return build(0, (ll)v.size(), v);",
      "  }",
      "",
      "  Node *build(ll l, ll r, const vector<T> &v) {",
      "    if (l + 1 == r) return my_new(v[l]);",
      "    ll m = (l + r) >> 1;",
      "    return merge(build(l, m, v), build(m, r, v));",
      "  }",
      "",
      "  Node *_update(ll a, const T &x, Node *n, ll l, ll r) {",
      "    if (l + 1 == r) return my_new(x);",
      "    ll m = (l + r) >> 1;",
      "    if (a < m) return merge(_update(a, x, n->l, l, m), n->r);",
      "    return merge(n->l, _update(a, x, n->r, m, r));",
      "  }",
      "",
      "  Node *update(Node *n, ll k, const T &x) {",
      "    Node *root = _update(k, x, n, 0, N);",
      "    roots.push_back(root);",
      "    return root;",
      "  }",
      "  Node *update(int t, ll k, const T &x) {",
      "    Node *root = _update(k, x, roots[t], 0, N);",
      "    roots.push_back(root);",
      "    return root;",
      "  }",
      "  Node *update(ll k, const T &x) {",
      "    Node *root = _update(k, x, roots.back(), 0, N);",
      "    roots.push_back(root);",
      "    return root;",
      "  }",
      "",
      "  Node *_add(ll a, const T &x, Node *n, ll l, ll r) {",
      "    if (l + 1 == r) return my_new(f(x, n->data));",
      "    ll m = (l + r) >> 1;",
      "    if (a < m) return merge(_add(a, x, n->l, l, m), n->r);",
      "    return merge(n->l, _add(a, x, n->r, m, r));",
      "  }",
      "",
      "  Node *add(Node *n, ll k, const T &x) {",
      "    Node *root = _add(k, x, n, 0, N);",
      "    roots.push_back(root);",
      "    return root;",
      "  }",
      "  Node *add(int t, ll k, const T &x) {",
      "    Node *root = _add(k, x, roots[t], 0, N);",
      "    roots.push_back(root);",
      "    return root;",
      "  }",
      "  Node *add(ll k, const T &x) {",
      "    Node *root = _add(k, x, roots.back(), 0, N);",
      "    roots.push_back(root);",
      "    return root;",
      "  }",
      "",
      "  T _query(ll a, ll b, Node *n, ll l, ll r) {",
      "    if (n == nil) return ID;",
      "    if (r <= a or b <= l) return ID;",
      "    if (a <= l and r <= b) return n->data;",
      "    ll m = (l + r) >> 1;",
      "    return f(_query(a, b, n->l, l, m), _query(a, b, n->r, m, r));",
      "  }",
      "",
      "  T query(Node *n, ll a, ll b) { return _query(a, b, n, 0, N); }",
      "  T query(int t, ll a, ll b) { return _query(a, b, roots[t], 0, N); }",
      "  T query(ll a, ll b) { return _query(a, b, roots.back(), 0, N); }",
      "};"
    ],
    "description": "PersistentSegmentTree"
  },
  "Dynamic_Segment_Tree": {
    "prefix": "_Dynamic_Segment_Tree",
    "body": [
      "",
      "template <typename T, typename F, int NODES = 4194304>",
      "struct DynamicSegmentTree {",
      "  using ll = long long;",
      "",
      "  struct Node {",
      "    T data;",
      "    Node *l, *r;",
      "    Node() {}",
      "    Node(const T &_data) : data(_data), l(nullptr), r(nullptr) {}",
      "  };",
      "",
      "  Node *pool;",
      "  int pid;",
      "  ll L, R;",
      "  const F &f;",
      "  const T ID;",
      "  Node *root;",
      "",
      "  DynamicSegmentTree(const vector<T> &v, const F &_f, const T &_ID)",
      "      : pid(0), L(0), R((ll)v.size()), f(_f), ID(_ID) {",
      "    pool = new Node[NODES];",
      "    root = build(v);",
      "  }",
      "",
      "  DynamicSegmentTree(const ll &_L, const ll &_R, const F &_f, const T &_ID)",
      "      : pid(0), L(_L), R(_R), f(_f), ID(_ID) {",
      "    pool = new Node[NODES];",
      "    root = my_new(ID);",
      "  }",
      "",
      "  Node *my_new(const T &data) {",
      "    pool[pid].data = data;",
      "    pool[pid].l = pool[pid].r = nullptr;",
      "    return &(pool[pid++]);",
      "  }",
      "",
      "  Node *my_new(Node *l, Node *r) {",
      "    pool[pid].data = f(l->data, r->data);",
      "    pool[pid].l = l;",
      "    pool[pid].r = r;",
      "    return &(pool[pid++]);",
      "  }",
      "",
      "  Node *build(const vector<T> &v) { return build(L, R, v); }",
      "",
      "  Node *build(ll l, ll r, const vector<T> &v) {",
      "    if (l + 1 == r) return my_new(v[l]);",
      "    ll m = (l + r) >> 1;",
      "    return my_new(build(l, m, v), build(m, r, v));",
      "  }",
      "",
      "  void _update(ll a, const T &x, Node *n, ll l, ll r) {",
      "    if (l + 1 == r) {",
      "      n->data = x;",
      "      return;",
      "    }",
      "    ll m = (l + r) >> 1;",
      "    if (a < m) {",
      "      if (!n->l) n->l = my_new(ID);",
      "      _update(a, x, n->l, l, m);",
      "    } else {",
      "      if (!n->r) n->r = my_new(ID);",
      "      _update(a, x, n->r, m, r);",
      "    }",
      "    n->data = f(n->l ? (n->l)->data : ID, n->r ? (n->r)->data : ID);",
      "  }",
      "",
      "  void update(ll k, const T &x) { _update(k, x, root, L, R); }",
      "",
      "  void add(ll k, const T &x) {",
      "    Node *n = root;",
      "    ll l = L, r = R;",
      "    n->data = f(n->data, x);",
      "    while (r - l > 1) {",
      "      ll m = (l + r) >> 1;",
      "      if (k < m) {",
      "        if (!n->l) n->l = my_new(ID);",
      "        n = n->l;",
      "        r = m;",
      "      } else {",
      "        if (!n->r) n->r = my_new(ID);",
      "        n = n->r;",
      "        l = m;",
      "      }",
      "      n->data = f(n->data, x);",
      "    }",
      "  }",
      "",
      "  T _query(ll a, ll b, Node *n, ll l, ll r) {",
      "    if (r <= a or b <= l) return ID;",
      "    if (a <= l and r <= b) return n->data;",
      "    ll m = (l + r) >> 1;",
      "    return f(n->l ? _query(a, b, n->l, l, m) : ID,",
      "             n->r ? _query(a, b, n->r, m, r) : ID);",
      "  }",
      "",
      "  T query(ll a, ll b) { return _query(a, b, root, L, R); }",
      "};"
    ],
    "description": "Dynamic_Segment_Tree"
  },
  "DSU_on_Tree_Guni_Sack": {
    "prefix": "_DSU_Guni_Sack",
    "body": [
      "template <typename G, typename UPDATE, typename QUERY, typename CLEAR,",
      "          typename RESET>",
      "struct DSUonTree {",
      "  G &g;",
      "  int N;",
      "  vector<int> sub_sz, euler, li, ri;",
      "  int idx;",
      "  UPDATE &update;",
      "  QUERY &query;",
      "  CLEAR &clear;",
      "  RESET &reset;",
      "",
      "  DSUonTree(G &_g, UPDATE &_update, QUERY &_query, CLEAR &_clear, RESET &_reset)",
      "      : g(_g),",
      "        N(_g.size()),",
      "        sub_sz(_g.size()),",
      "        euler(_g.size()),",
      "        li(_g.size()),",
      "        ri(_g.size()),",
      "        idx(0),",
      "        update(_update),",
      "        query(_query),",
      "        clear(_clear),",
      "        reset(_reset) {",
      "    dfs1();",
      "    dfs2();",
      "  }",
      "",
      "  int dfs1(int cur = 0, int par = -1) {",
      "    sub_sz[cur] = 1;",
      "    if ((int)g[cur].size() >= 2 and g[cur][0] == par) {",
      "      swap(g[cur][0], g[cur][1]);",
      "    }",
      "    for (auto &dst : g[cur]) {",
      "      if (dst == par) continue;",
      "      sub_sz[cur] += dfs1(dst, cur);",
      "      if (sub_sz[dst] > sub_sz[g[cur][0]]) swap(dst, g[cur][0]);",
      "    }",
      "    return sub_sz[cur];",
      "  }",
      "",
      "  void dfs2(int cur = 0, int par = -1) {",
      "    euler[idx] = cur;",
      "    li[cur] = idx++;",
      "    for (auto &dst : g[cur]) {",
      "      if (dst == par) continue;",
      "      dfs2(dst, cur);",
      "    }",
      "    ri[cur] = idx;",
      "  }",
      "",
      "  void dsu(int cur = 0, int par = -1, int keep = 1) {",
      "    // light edge -> run dfs and clear data",
      "    for (int i = 1; i < (int)g[cur].size(); i++)",
      "      if (g[cur][i] != par) dsu(g[cur][i], cur, false);",
      "",
      "    // heavy edge -> run dfs and reserve data",
      "    if (sub_sz[cur] != 1) dsu(g[cur][0], cur, true);",
      "",
      "    // light edge -> reserve data",
      "    if (sub_sz[cur] != 1)",
      "      for (int i = ri[g[cur][0]]; i < ri[cur]; i++) update(euler[i]);",
      "",
      "    // current node -> reserve data",
      "    update(cur);",
      "",
      "    // answer queries related to subtree of current node",
      "    query(cur);",
      "",
      "    // if keep is false, clear all data",
      "    if (!keep) {",
      "      for (int i = li[cur]; i < ri[cur]; i++) clear(euler[i]);",
      "      reset();",
      "    }",
      "    return;",
      "  }",
      "",
      "  void run() { dsu(); }",
      "};",
      "",
      "/*",
      "  // reflect data of node i",
      "  auto update = [&](int i) {",
      "",
      "  };",
      "  // answer queries of subtree i",
      "  auto query = [&](int i) {",
      "",
      "  };",
      "  // below two function are called if all data must be deleted",
      "  // delete data of node i (if necesarry)",
      "  auto clear = [&](int i) {",
      "",
      "  };",
      "  // delete data related to all (if necesarry)",
      "  auto reset = [&]() {",
      "",
      "  };",
      "  DSUonTree<decltype(g), decltype(update), decltype(query), decltype(clear),",
      "            decltype(reset)>",
      "      dsu(g, update, query, clear, reset);",
      "  dsu.run();",
      "*/"
    ],
    "description": "DSU_on_Tree_Guni_Sack"
  },
  "Grid_kakikake": {
    "prefix": "_grid_input",
    "body": [
      "struct Grid {",
      "  int H, W;",
      "  vector<vector<int>> g;",
      "",
      "  Grid(int h, int w) : H(h), W(w), g(h * w) {}",
      "  Grid(int n) : H(n), W(n), g(n * n) {}",
      "",
      "  inline int id(int h, int w) { return h * W + w; }",
      "",
      "  inline int ok(int h, int w) { return 0 <= h and h < H and 0 <= w and w < W; }",
      "",
      "  operator vector<vector<int>> &() { return g; }",
      "",
      "  void add(int h0, int w0, int h1, int w1, int is_directed = false) {",
      "    g[id(h0, w0)].push_back(id(h1, w1));",
      "    if (!is_directed) g[id(h1, w1)].push_back(id(h0, w0));",
      "  }",
      "",
      "  vector<int> &es(int h, int w) { return g[id(h, w)]; }",
      "",
      "  void convert(vector<string> &s, int is_8_direction = false, char ng = '#') {",
      "    for (int i = 0; i < H - 1; i++)",
      "      for (int j = 0; j < W; j++)",
      "        if (s[i][j] != ng and s[i + 1][j] != ng) add(i, j, i + 1, j);",
      "    for (int j = 0; j < W - 1; j++)",
      "      for (int i = 0; i < H; i++)",
      "        if (s[i][j] != ng and s[i][j + 1] != ng) add(i, j, i, j + 1);",
      "    if (is_8_direction)",
      "      for (int i = 0; i < H - 1; i++)",
      "        for (int j = 0; j < W - 1; j++) {",
      "          if (s[i][j] != ng and s[i + 1][j + 1] != ng) add(i, j, i + 1, j + 1);",
      "          if (s[i][j + 1] != ng and s[i + 1][j] != ng) add(i, j + 1, i + 1, j);",
      "        }",
      "  }",
      "};",
      "",
      "Grid ggraph(int H, int W, int is_8_direction = false, char ng = '#') {",
      "  vector<string> s;",
      "  cin >> s;",
      "  Grid g(H, W);",
      "  g.convert(s, is_8_direction, ng);",
      "  return std::move(g);",
      "}"
    ],
    "description": "Grid_kakikake"
  },
  "Dimension_Expanded_Graph": {
    "prefix": "_dimension_expanded_graph",
    "body": [
      "template <int DIM>",
      "struct DimensionExpandedGraph {",
      "  using i64 = long long;",
      "  using A = array<int, DIM>;",
      "",
      "  int N;",
      "  A g_size, coeff;",
      "",
      "  template <typename... T>",
      "  DimensionExpandedGraph(const T &... t) : N(1), g_size({t...}) {",
      "    set_coeff();",
      "  }",
      "",
      "  void set_coeff() {",
      "    coeff.fill(1);",
      "    for (int i = 0; i < DIM; i++) {",
      "      for (int j = 0; j < i; j++) coeff[j] *= g_size[i];",
      "      N *= g_size[i];",
      "    }",
      "  }",
      "",
      "  int id(const A &a) {",
      "    int ret = 0;",
      "    for (int i = 0; i < DIM; i++) ret += a[i] * coeff[i];",
      "    return ret;",
      "  }",
      "",
      "  template <typename... T>",
      "  int id(const T &... t) {",
      "    return id(A({t...}));",
      "  }",
      "",
      "  int ok(const A &a) {",
      "    for (int i = 0; i < DIM; i++)",
      "      if (a[i] < 0 or g_size[i] <= a[i]) return false;",
      "    return true;",
      "  }",
      "",
      "  template <typename... T>",
      "  int ok(const T &... t) {",
      "    return ok(A({t...}));",
      "  }",
      "",
      "  template <typename F>",
      "  vector<i64> bfs(F f, A s = {}) {",
      "    vector<i64> dist(N, -1);",
      "    queue<A> Q;",
      "    dist[id(s)] = 0;",
      "    Q.push(s);",
      "    while (!Q.empty()) {",
      "      A c = Q.front();",
      "      Q.pop();",
      "      f(c, [&](A d) {",
      "        if (dist[id(d)] == -1) {",
      "          dist[id(d)] = dist[id(c)] + 1;",
      "          Q.push(d);",
      "        }",
      "      });",
      "    }",
      "    return dist;",
      "  }",
      "",
      "  template <typename F>",
      "  vector<i64> bfs01(F f, A s = {}) {",
      "    vector<i64> dist(N, -1);",
      "    deque<A> Q;",
      "    dist[id(s)] = 0;",
      "    Q.push_back(s);",
      "    while (!Q.empty()) {",
      "      A c = Q.front();",
      "      Q.pop_front();",
      "      f(c, [&](A d, i64 w) {",
      "        if (dist[id(d)] == -1) {",
      "          dist[id(d)] = dist[id(c)] + w;",
      "          if (w == 0)",
      "            Q.push_front(d);",
      "          else",
      "            Q.push_back(d);",
      "        }",
      "      });",
      "    }",
      "    return dist;",
      "  }",
      "",
      "  template <typename F>",
      "  vector<i64> dijkstra(F f, A s = {}) {",
      "    vector<i64> dist(N, -1);",
      "    using P = pair<i64, A>;",
      "    priority_queue<P, vector<P>, greater<P>> Q;",
      "    Q.emplace(dist[id(s)] = 0, s);",
      "    while (!Q.empty()) {",
      "      i64 d;",
      "      A c;",
      "      tie(d, c) = Q.top();",
      "      Q.pop();",
      "      if (dist[id(c)] < d) continue;",
      "      f(c, [&](A d, i64 w) {",
      "        if (dist[id(d)] == -1 or dist[id(d)] > dist[id(c)] + w) {",
      "          Q.emplace(dist[id(d)] = dist[id(c)] + w, d);",
      "        }",
      "      });",
      "    }",
      "    return dist;",
      "  }",
      "};",
      "",
      "/*",
      "auto f = [&](g::A cu, auto ret) -> void{",
      "  auto [] = cu;",
      "  // for each ds, ret(ds) or ret(ds, weight of edge cu-ds)",
      "",
      "};",
      "*/"
    ],
    "description": "Dimension_Expanded_Graph"
  },
  "Euler_Tour": {
    "prefix": "_EulerTour",
    "body": [
      "// 頂点のオイラーツアー",
      "struct EulerTour {",
      "  struct UnionFind {",
      "    vector<int> data;",
      "    UnionFind(int N) : data(N, -1) {}",
      "",
      "    int find(int k) { return data[k] < 0 ? k : data[k] = find(data[k]); }",
      "",
      "    int unite(int x, int y) {",
      "      if ((x = find(x)) == (y = find(y))) return false;",
      "      if (data[x] > data[y]) swap(x, y);",
      "      data[x] += data[y];",
      "      data[y] = x;",
      "      return true;",
      "    }",
      "",
      "    int size(int k) { return -data[find(k)]; }",
      "",
      "    int same(int x, int y) { return find(x) == find(y); }",
      "  };",
      "",
      "  struct SegmentTree_RangeMin {",
      "    int size;",
      "    using P = pair<int, int>;",
      "    vector<P> seg;",
      "    P UNIT = P(1 << 30, -1);",
      "",
      "    SegmentTree_RangeMin() {}",
      "",
      "    SegmentTree_RangeMin(int N) {",
      "      size = 1;",
      "      while (size < N) size <<= 1;",
      "      seg.assign(2 * size, UNIT);",
      "    }",
      "",
      "    void set(int k, P x) { seg[k + size] = x; }",
      "",
      "    void build() {",
      "      for (int k = size - 1; k > 0; k--) {",
      "        seg[k] = min(seg[2 * k], seg[2 * k + 1]);",
      "      }",
      "    }",
      "",
      "    // query to [a, b)",
      "    P query(int a, int b) {",
      "      P L = UNIT, R = UNIT;",
      "      for (a += size, b += size; a < b; a >>= 1, b >>= 1) {",
      "        if (a & 1) L = min(L, seg[a++]);",
      "        if (b & 1) R = min(seg[--b], R);",
      "      }",
      "      return min(L, R);",
      "    }",
      "  };",
      "",
      "  using G = vector<vector<int>>;",
      "",
      "  UnionFind uf;",
      "  vector<int> down, up, tour, par, depth;",
      "  int i_;",
      "  SegmentTree_RangeMin lca_seg;",
      "",
      "  EulerTour(G &g)",
      "      : uf(g.size()),",
      "        down(g.size(), -1),",
      "        up(g.size()),",
      "        tour(g.size() * 2),",
      "        par(g.size()),",
      "        depth(g.size(), -1),",
      "        i_(0),",
      "        lca_seg(2 * g.size()) {",
      "    vector<int> isroot(g.size(), 1);",
      "    for (int i = 0; i < (int)g.size(); i++) {",
      "      for (auto &d : g[i]) isroot[d] = 0;",
      "    }",
      "    for (int i = 0; i < (int)g.size(); i++) {",
      "      if (!isroot[i]) continue;",
      "      dfs(g, i, -1);",
      "    }",
      "    lca_seg.build();",
      "",
      "    trc(down);",
      "    trc(up);",
      "    trc(tour);",
      "  }",
      "",
      "  void dfs(G &g, int c, int p) {",
      "    trc(c, p);",
      "    down[c] = i_;",
      "    par[c] = p;",
      "    depth[c] = ~p ? depth[p] + 1 : 0;",
      "    lca_seg.set(i_, {depth[c], c});",
      "    tour[i_++] = c;",
      "    if (~p) uf.unite(c, p);",
      "    for (auto &d : g[c]) {",
      "      if (d == p) continue;",
      "      dfs(g, d, c);",
      "    }",
      "    up[c] = i_;",
      "    if (~p) lca_seg.set(i_, {depth[p], p});",
      "    tour[i_++] = c;",
      "  }",
      "",
      "  int lca(int a, int b) {",
      "    if (!uf.same(a, b)) return -1;",
      "    if (down[a] > down[b]) swap(a, b);",
      "    return lca_seg.query(down[a], down[b] + 1).second;",
      "  }",
      "",
      "  template <typename F>",
      "  void node_query(int a, int b, F &f) {",
      "    int l = lca(a, b);",
      "    assert(l != -1);",
      "    f(down[l], down[a] + 1);",
      "    f(down[l] + 1, down[b] + 1);",
      "  }",
      "",
      "  template <typename F>",
      "  void edge_query(int a, int b, F &f) {",
      "    int l = lca(a, b);",
      "    assert(l != -1);",
      "    f(down[l] + 1, down[a] + 1);",
      "    f(down[l] + 1, down[b] + 1);",
      "  }",
      "};"
    ],
    "description": "Euler_Tour"
  },
  "Range_Weighted_Add_Range_Sum_SegTree": {
    "prefix": "_Range_Weighted_Add_Range_Sum_SegTree",
    "body": [
      "template<typename T,typename E>",
      "struct Range_Weighted_Add_Range_Sum_SegTree {",
      "  int n, height;",
      "  T ti = {0, 0};",
      "  E ei = 0;",
      "  vector<T> dat;",
      "  vector<E> laz;",
      "  Range_Weighted_Add_Range_Sum_SegTree(const vector<T> &v) {",
      "    init((int)v.size());",
      "    build(v);",
      "  }",
      "",
      "  void init(int n_) {",
      "    n = 1;",
      "    height = 0;",
      "    while (n < n_) n <<= 1, height++;",
      "    dat.assign(2 * n, ti);",
      "    laz.assign(2 * n, ei);",
      "  }",
      "  void build(const vector<T> &v) {",
      "    int n_ = v.size();",
      "    init(n_);",
      "    for (int i = 0; i < n_; i++) dat[n + i] = v[i];",
      "    for (int i = n - 1; i; i--) {",
      "      dat[i].first = dat[(i << 1) | 0].first + dat[(i << 1) | 1].first;",
      "      dat[i].second = dat[(i << 1) | 0].second + dat[(i << 1) | 1].second;",
      "    }",
      "  }",
      "  inline T reflect(int k) {",
      "    return laz[k] == ei",
      "               ? dat[k]",
      "               : T{dat[k].first + laz[k] * dat[k].second, dat[k].second};",
      "  }",
      "  inline void eval(int k) {",
      "    if (laz[k] == ei) return;",
      "    laz[(k << 1) | 0] += laz[k];",
      "    laz[(k << 1) | 1] += laz[k];",
      "    dat[k] = reflect(k);",
      "    laz[k] = ei;",
      "  }",
      "  inline void thrust(int k) {",
      "    for (int i = height; i; i--) eval(k >> i);",
      "  }",
      "  inline void recalc(int k) {",
      "    while (k >>= 1)",
      "      dat[k].first = reflect((k << 1) | 0).first + reflect((k << 1) | 1).first;",
      "  }",
      "  void update(int a, int b, E x) {",
      "    thrust(a += n);",
      "    thrust(b += n - 1);",
      "    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
      "      if (l & 1) laz[l] += x, l++;",
      "      if (r & 1) --r, laz[r] += x;",
      "    }",
      "    recalc(a);",
      "    recalc(b);",
      "  }",
      "  void update(int a, E x) {",
      "    thrust(a += n);",
      "    laz[a] += x;",
      "    recalc(a);",
      "  }",
      "",
      "  void set_val(int a, T x) {",
      "    thrust(a += n);",
      "    dat[a] = x;",
      "    laz[a] = ei;",
      "    recalc(a);",
      "  }",
      "",
      "  E query(int a, int b) {",
      "    thrust(a += n);",
      "    thrust(b += n - 1);",
      "    E ret = ei;",
      "    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
      "      if (l & 1) ret += reflect(l++).first;",
      "      if (r & 1) ret += reflect(--r).first;",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  E query(int a) {",
      "    thrust(a += n);",
      "    return reflect(a).first;",
      "  }",
      "};",
      ""
    ],
    "description": "Range_Weighted_Add_Range_Sum_SegTree"
  },
  "Cartesian_Tree": {
    "prefix": "_CartesianTree",
    "body": [
      "// return value : pair<graph, root>",
      "template <typename T>",
      "pair<vector<vector<int>>, int> CartesianTree(vector<T> &a) {",
      "  int N = (int)a.size();",
      "  vector<vector<int>> g(N);",
      "  vector<int> p(N, -1), st;",
      "  st.reserve(N);",
      "  for (int i = 0; i < N; i++) {",
      "    int prv = -1;",
      "    while (!st.empty() && a[i] < a[st.back()]) {",
      "      prv = st.back();",
      "      st.pop_back();",
      "    }",
      "    if (prv != -1) p[prv] = i;",
      "    if (!st.empty()) p[i] = st.back();",
      "    st.push_back(i);",
      "  }",
      "  int root = -1;",
      "  for (int i = 0; i < N; i++) {",
      "    if (p[i] != -1)",
      "      g[p[i]].push_back(i);",
      "    else",
      "      root = i;",
      "  }",
      "  return make_pair(g, root);",
      "}"
    ],
    "description": "Cartesian_Tree"
  },
  "Timer": {
    "prefix": "_timer",
    "body": [
      "struct Timer {",
      "  chrono::high_resolution_clock::time_point st;",
      "",
      "  Timer() { reset(); }",
      "",
      "  void reset() { st = chrono::high_resolution_clock::now(); }",
      "",
      "  chrono::milliseconds::rep elapsed() {",
      "    auto ed = chrono::high_resolution_clock::now();",
      "    return chrono::duration_cast<chrono::milliseconds>(ed - st).count();",
      "  }",
      "};"
    ],
    "description": "Timer"
  },
  "Dynamic_Union_Find": {
    "prefix": "_DynamicUnionFind",
    "body": [
      "",
      "struct DynamicUnionFind {",
      "  unordered_map<int, int> m;",
      "  DynamicUnionFind() {}",
      "",
      "  int data(int k) {",
      "    auto itk = m.find(k);",
      "    return itk == m.end() ? m[k] = -1 : itk->second;",
      "  }",
      "  int find(int k) {",
      "    int datk = data(k);",
      "    return datk < 0 ? k : m[k] = find(datk);",
      "  }",
      "",
      "  int unite(int x, int y) {",
      "    if ((x = find(x)) == (y = find(y))) return false;",
      "    auto itx = m.find(x), ity = m.find(y);",
      "    if (itx->second > ity->second) {",
      "      ity->second += itx->second;",
      "      itx->second = y;",
      "    } else {",
      "      itx->second += ity->second;",
      "      ity->second = x;",
      "    }",
      "    return true;",
      "  }",
      "",
      "  int size(int k) { return -data(find(k)); }",
      "",
      "  int same(int x, int y) { return find(x) == find(y); }",
      "};"
    ],
    "description": "Dynamic_Union_Find"
  },
  "ebichan_fastio": {
    "prefix": "_ebichan",
    "body": [
      "#ifdef Nyaan",
      "#define long long long",
      "#endif",
      "",
      "/**",
      " * @brief 高速入出力",
      " * @author えびちゃん",
      " * @see https://qiita.com/rsk0315_h4x/items/17a9cb12e0de5fd918f4",
      " */",
      "namespace ebichan_fast {",
      "static constexpr size_t buf_size = 1 << 17;",
      "static constexpr size_t margin = 1;",
      "static char inbuf[buf_size + margin] = {};",
      "static __attribute__((aligned(8))) char outbuf[buf_size + margin] = {};",
      "static __attribute__((aligned(8))) char minibuf[32];",
      "static constexpr size_t int_digits = 20;  // 18446744073709551615",
      "static constexpr uintmax_t digit_mask = 0x3030303030303030;",
      "static constexpr uintmax_t first_mask = 0x00FF00FF00FF00FF;",
      "static constexpr uintmax_t second_mask = 0x0000FFFF0000FFFF;",
      "static constexpr uintmax_t third_mask = 0x00000000FFFFFFFF;",
      "static constexpr uintmax_t tenpow[] = {",
      "    1,",
      "    10,",
      "    100,",
      "    1000,",
      "    10000,",
      "    100000,",
      "    1000000,",
      "    10000000,",
      "    100000000,",
      "    1000000000,",
      "    10000000000,",
      "    100000000000,",
      "    1000000000000,",
      "    10000000000000,",
      "    100000000000000,",
      "    1000000000000000,",
      "    10000000000000000,",
      "    100000000000000000,",
      "    1000000000000000000,",
      "    10000000000000000000u,",
      "};",
      "static __attribute__((",
      "    aligned(8))) char inttab[40000] = {};  // 4-digit integers (10000 many)",
      "static char S_sep = ' ', S_end = '\\n';",
      "template <typename Tp>",
      "using enable_if_integral = std::enable_if<std::is_integral<Tp>::value, Tp>;",
      "",
      "class scanner {",
      "  char *pos = inbuf;",
      "  char *endpos = inbuf + buf_size;",
      "",
      "  void M_read_from_stdin() { endpos = inbuf + fread(pos, 1, buf_size, stdin); }",
      "  void M_reread_from_stdin() {",
      "    ptrdiff_t len = endpos - pos;",
      "    if (!(inbuf + len <= pos)) return;",
      "    memcpy(inbuf, pos, len);",
      "    char *tmp = inbuf + len;",
      "    endpos = tmp + fread(tmp, 1, buf_size - len, stdin);",
      "    *endpos = 0;",
      "    pos = inbuf;",
      "  }",
      "",
      " public:",
      "  scanner() { M_read_from_stdin(); }",
      "",
      "  template <typename Integral,",
      "            typename enable_if_integral<Integral>::type * = nullptr>",
      "  void scan_parallel(Integral &x) {",
      "    if (__builtin_expect(endpos <= pos + int_digits, 0)) M_reread_from_stdin();",
      "    bool ends = false;",
      "    typename std::make_unsigned<Integral>::type y = 0;",
      "    bool neg = false;",
      "    if (std::is_signed<Integral>::value && *pos == '-') {",
      "      neg = true;",
      "      ++pos;",
      "    }",
      "    do {",
      "      memcpy(minibuf, pos, 8);",
      "      long c = *(long *)minibuf;",
      "      long d = (c & digit_mask) ^ digit_mask;",
      "      int skip = 8;",
      "      int shift = 8;",
      "      if (d) {",
      "        int ctz = __builtin_ctzl(d);",
      "        if (ctz == 4) break;",
      "        c &= (1L << (ctz - 5)) - 1;",
      "        int discarded = (68 - ctz) / 8;",
      "        shift -= discarded;",
      "        c <<= discarded * 8;",
      "        skip -= discarded;",
      "        ends = true;",
      "      }",
      "      c |= digit_mask;",
      "      c ^= digit_mask;",
      "      c = ((c >> 8) + c * 10) & first_mask;",
      "      c = ((c >> 16) + c * 100) & second_mask;",
      "      c = ((c >> 32) + c * 10000) & third_mask;",
      "      y = y * tenpow[shift] + c;",
      "      pos += skip;",
      "    } while (!ends);",
      "    x = (neg ? -y : y);",
      "    ++pos;",
      "  }",
      "",
      "  template <typename Integral,",
      "            typename enable_if_integral<Integral>::type * = nullptr>",
      "  void scan_serial(Integral &x) {",
      "    if (__builtin_expect(endpos <= pos + int_digits, 0)) M_reread_from_stdin();",
      "    bool neg = false;",
      "    if (std::is_signed<Integral>::value && *pos == '-') {",
      "      neg = true;",
      "      ++pos;",
      "    }",
      "    typename std::make_unsigned<Integral>::type y = *pos - '0';",
      "    while (*++pos >= '0') y = 10 * y + *pos - '0';",
      "    x = (neg ? -y : y);",
      "    ++pos;",
      "  }",
      "",
      "  template <typename Integral,",
      "            typename enable_if_integral<Integral>::type * = nullptr>",
      "  // Use scan_parallel(x) only when x may be too large (about 10^12).",
      "  // Otherwise, even when x <= 10^9, scan_serial(x) may be faster.",
      "  void scan(Integral &x) {",
      "    scan_parallel(x);",
      "  }",
      "",
      "  void scan_serial(std::string &s) {",
      "    // until first whitespace",
      "    s = \"\";",
      "    do {",
      "      char *startpos = pos;",
      "      while (*pos > ' ') ++pos;",
      "      s += std::string(startpos, pos);",
      "      if (*pos != 0) {",
      "        ++pos;  // skip the space",
      "        break;",
      "      }",
      "      M_reread_from_stdin();",
      "    } while (true);",
      "  }",
      "",
      "  void scan(std::string &s) { scan_serial(s); }",
      "",
      "  template <typename Tp, typename... Args>",
      "  void scan(Tp &x, Args &&... xs) {",
      "    scan(x);",
      "    scan(std::forward<Args>(xs)...);",
      "  }",
      "};",
      "",
      "class printer {",
      "  char *pos = outbuf;",
      "",
      "  void M_flush_stdout() {",
      "    fwrite(outbuf, 1, pos - outbuf, stdout);",
      "    pos = outbuf;",
      "  }",
      "",
      "  static int S_int_digits(uintmax_t n) {",
      "    if (n < tenpow[16]) {                 // 1",
      "      if (n < tenpow[8]) {                // 2",
      "        if (n < tenpow[4]) {              // 3",
      "          if (n < tenpow[2]) {            // 4",
      "            if (n < tenpow[1]) return 1;  // 5",
      "            return 2;                     // 5",
      "          }",
      "          if (n < tenpow[3]) return 3;  // 4",
      "          return 4;                     // 4",
      "        }",
      "        if (n < tenpow[6]) {            // 4",
      "          if (n < tenpow[5]) return 5;  // 5",
      "          return 6;                     // 5",
      "        }",
      "        if (n < tenpow[7]) return 7;  // 5",
      "        return 8;                     // 5",
      "      }",
      "      if (n < tenpow[12]) {             // 3",
      "        if (n < tenpow[10]) {           // 4",
      "          if (n < tenpow[9]) return 9;  // 5",
      "          return 10;                    // 5",
      "        }",
      "        if (n < tenpow[11]) return 11;  // 5",
      "        return 12;                      // 5",
      "      }",
      "      if (n < tenpow[14]) {             // 4",
      "        if (n < tenpow[13]) return 13;  // 5",
      "        return 14;                      // 5",
      "      }",
      "      if (n < tenpow[15]) return 15;  // 5",
      "      return 16;                      // 5",
      "    }",
      "    if (n < tenpow[18]) {             // 2",
      "      if (n < tenpow[17]) return 17;  // 3",
      "      return 18;                      // 3",
      "    }",
      "    return 19;  // 2",
      "    // if (n < tenpow[19]) return 19;  // 3",
      "    // return 20;  // 3",
      "  }",
      "",
      "  void M_precompute() {",
      "    unsigned long const digit1 = 0x0200000002000000;",
      "    unsigned long const digit2 = 0xf600fffff6010000;",
      "    unsigned long const digit3 = 0xfff600fffff60100;",
      "    unsigned long const digit4 = 0xfffff600fffff601;",
      "    unsigned long counter = 0x3130303030303030;",
      "    for (int i = 0, i4 = 0; i4 < 10; ++i4, counter += digit4)",
      "      for (int i3 = 0; i3 < 10; ++i3, counter += digit3)",
      "        for (int i2 = 0; i2 < 10; ++i2, counter += digit2)",
      "          for (int i1 = 0; i1 < 5; ++i1, ++i, counter += digit1)",
      "            *((unsigned long *)inttab + i) = counter;",
      "  }",
      "",
      " public:",
      "  printer() { M_precompute(); }",
      "  ~printer() { M_flush_stdout(); }",
      "",
      "  void print(char c) {",
      "    if (__builtin_expect(pos + 1 >= outbuf + buf_size, 0)) M_flush_stdout();",
      "    *pos++ = c;",
      "  }",
      "",
      "  template <size_t N>",
      "  void print(char const (&s)[N]) {",
      "    if (__builtin_expect(pos + N >= outbuf + buf_size, 0)) M_flush_stdout();",
      "    memcpy(pos, s, N - 1);",
      "    pos += N - 1;",
      "  }",
      "",
      "  void print(char const *s) {",
      "    // FIXME: strlen や memcpy などで定数倍高速化したい",
      "    while (*s != 0) {",
      "      *pos++ = *s++;",
      "      if (pos == outbuf + buf_size) M_flush_stdout();",
      "    }",
      "  }",
      "",
      "  void print(std::string const &s) { print(s.data()); }",
      "",
      "  template <typename Integral,",
      "            typename enable_if_integral<Integral>::type * = nullptr>",
      "  void print(Integral x) {",
      "    if (__builtin_expect(pos + int_digits >= outbuf + buf_size, 0))",
      "      M_flush_stdout();",
      "    if (x == 0) {",
      "      *pos++ = '0';",
      "      return;",
      "    }",
      "    if (x < 0) {",
      "      *pos++ = '-';",
      "      if (__builtin_expect(x == std::numeric_limits<Integral>::min(), 0)) {",
      "        switch (sizeof x) {",
      "          case 2:",
      "            print(\"32768\");",
      "            return;",
      "          case 4:",
      "            print(\"2147483648\");",
      "            return;",
      "          case 8:",
      "            print(\"9223372036854775808\");",
      "            return;",
      "        }",
      "      }",
      "      x = -x;",
      "    }",
      "",
      "    typename std::make_unsigned<Integral>::type y = x;",
      "    int len = S_int_digits(y);",
      "    pos += len;",
      "    char *tmp = pos;",
      "    int w = (pos - outbuf) & 3;",
      "    if (w > len) w = len;",
      "    for (int i = w; i > 0; --i) {",
      "      *--tmp = y % 10 + '0';",
      "      y /= 10;",
      "    }",
      "    len -= w;",
      "    while (len >= 4) {",
      "      tmp -= 4;",
      "      *(unsigned *)tmp = *((unsigned *)inttab + (y % 10000));",
      "      len -= 4;",
      "      if (len) y /= 10000;",
      "    }",
      "    while (len-- > 0) {",
      "      *--tmp = y % 10 + '0';",
      "      y /= 10;",
      "    }",
      "  }",
      "",
      "  template <typename Tp, typename... Args>",
      "  void print(Tp const &x, Args &&... xs) {",
      "    if (sizeof...(Args) > 0) {",
      "      print(x);",
      "      print(S_sep);",
      "      print(std::forward<Args>(xs)...);",
      "    }",
      "  }",
      "",
      "  template <typename Tp>",
      "  void println(Tp const &x) {",
      "    print(x), print(S_end);",
      "  }",
      "",
      "  template <typename Tp, typename... Args>",
      "  void println(Tp const &x, Args &&... xs) {",
      "    print(x, std::forward<Args>(xs)...);",
      "    print(S_end);",
      "  }",
      "",
      "  static void set_sep(char c) { S_sep = c; }",
      "  static void set_end(char c) { S_end = c; }",
      "",
      "#ifdef Nyaan",
      "#undef long",
      "#endif",
      "};",
      "}  // namespace ebichan_fast",
      "",
      "ebichan_fast::scanner fastin;",
      "ebichan_fast::printer fastout;"
    ],
    "description": "ebichan_fastio"
  },
  "NTT_using_SIMD": {
    "prefix": "_SIMD_FFT",
    "body": [
      "using mint = LazyMontgomeryModInt<MOD>;",
      "using vm = V<mint>;",
      "constexpr int SZ = 1 << 19;",
      "mint buf1[SZ * 2] __attribute__((aligned(64)));",
      "mint buf2[SZ * 2] __attribute__((aligned(64)));",
      "",
      "#include <immintrin.h>",
      "using u32 = uint32_t;",
      "using u64 = uint64_t;",
      "__attribute__((always_inline)) __m128i my_mullo_epu32(const __m128i &a,",
      "                                                      const __m128i &b) {",
      "#if defined(__SSE4_2__)",
      "  return _mm_mullo_epi32(a, b);",
      "#else",
      "  __m128i a13 = _mm_shuffle_epi32(a, 0xF5);",
      "  __m128i b13 = _mm_shuffle_epi32(b, 0xF5);",
      "  __m128i prod02 = _mm_mul_epu32(a, b);",
      "  __m128i prod13 = _mm_mul_epu32(a13, b13);",
      "  __m128i prod = _mm_unpacklo_epi64(_mm_unpacklo_epi32(prod02, prod13),",
      "                                    _mm_unpackhi_epi32(prod02, prod13));",
      "  return prod;",
      "#endif",
      "}",
      "",
      "__attribute__((always_inline)) __m128i my_mulhi_epu32(const __m128i &a,",
      "                                                      const __m128i &b) {",
      "  __m128i a13 = _mm_shuffle_epi32(a, 0xF5);",
      "  __m128i b13 = _mm_shuffle_epi32(b, 0xF5);",
      "  __m128i prod02 = _mm_mul_epu32(a, b);",
      "  __m128i prod13 = _mm_mul_epu32(a13, b13);",
      "  __m128i prod = _mm_unpackhi_epi64(_mm_unpacklo_epi32(prod02, prod13),",
      "                                    _mm_unpackhi_epi32(prod02, prod13));",
      "  return prod;",
      "}",
      "",
      "__attribute__((always_inline)) __m128i montgomery_mul(const __m128i &a,",
      "                                                      const __m128i &b,",
      "                                                      const __m128i &r,",
      "                                                      const __m128i &m1) {",
      "  return _mm_sub_epi32(",
      "      _mm_add_epi32(my_mulhi_epu32(a, b), m1),",
      "      my_mulhi_epu32(my_mullo_epu32(my_mullo_epu32(a, b), r), m1));",
      "}",
      "",
      "__attribute__((always_inline)) __m128i montgomery_add(const __m128i &a,",
      "                                                      const __m128i &b,",
      "                                                      const __m128i &m2,",
      "                                                      const __m128i &m0) {",
      "  __m128i ret = _mm_sub_epi32(_mm_add_epi32(a, b), m2);",
      "  return _mm_add_epi32(_mm_and_si128(_mm_cmpgt_epi32(m0, ret), m2), ret);",
      "}",
      "",
      "__attribute__((always_inline)) __m128i montgomery_sub(const __m128i &a,",
      "                                                      const __m128i &b,",
      "                                                      const __m128i &m2,",
      "                                                      const __m128i &m0) {",
      "  __m128i ret = _mm_sub_epi32(a, b);",
      "  return _mm_add_epi32(_mm_and_si128(_mm_cmpgt_epi32(m0, ret), m2), ret);",
      "}",
      "",
      "template <typename mint>",
      "struct NTT {",
      "  static constexpr uint32_t get_pr() {",
      "    uint32_t mod = mint::get_mod();",
      "    using u64 = uint64_t;",
      "    u64 ds[32] = {};",
      "    int idx = 0;",
      "    u64 m = mod - 1;",
      "    for (u64 i = 2; i * i <= m; ++i) {",
      "      if (m % i == 0) {",
      "        ds[idx++] = i;",
      "        while (m % i == 0) m /= i;",
      "      }",
      "    }",
      "    if (m != 1) ds[idx++] = m;",
      "",
      "    uint32_t pr = 2;",
      "    while (1) {",
      "      int flg = 1;",
      "      for (int i = 0; i < idx; ++i) {",
      "        u64 a = pr, b = (mod - 1) / ds[i], r = 1;",
      "        while (b) {",
      "          if (b & 1) r = r * a % mod;",
      "          a = a * a % mod;",
      "          b >>= 1;",
      "        }",
      "        if (r == 1) {",
      "          flg = 0;",
      "          break;",
      "        }",
      "      }",
      "      if (flg == 1) break;",
      "      ++pr;",
      "    }",
      "    return pr;",
      "  };",
      "",
      "  static constexpr uint32_t mod = mint::get_mod();",
      "  static constexpr uint32_t pr = get_pr();",
      "  static constexpr int level = __builtin_ctzll(mod - 1);",
      "  mint dw[level], dy[level];",
      "",
      "  NTT() { setwy(level); }",
      "",
      "  constexpr void setwy(int k) {",
      "    mint w[level], y[level];",
      "    w[k - 1] = mint(pr).pow((mod - 1) / (1 << k));",
      "    y[k - 1] = w[k - 1].inverse();",
      "    for (int i = k - 2; i > 0; --i)",
      "      w[i] = w[i + 1] * w[i + 1], y[i] = y[i + 1] * y[i + 1];",
      "    dw[1] = w[1], dy[1] = y[1], dw[2] = w[2], dy[2] = y[2];",
      "    for (int i = 3; i < k; ++i) {",
      "      dw[i] = dw[i - 1] * y[i - 2] * w[i];",
      "      dy[i] = dy[i - 1] * w[i - 2] * y[i];",
      "    }",
      "  }",
      "",
      "  void ntt(mint *a, int n) {",
      "    int k = n ? __builtin_ctz(n) : 0;",
      "    if (k == 0) return;",
      "    if (k == 1) {",
      "      mint a1 = a[1];",
      "      a[1] = a[0] - a[1];",
      "      a[0] = a[0] + a1;",
      "      return;",
      "    }",
      "    if (k & 1) {",
      "      int v = 1 << (k - 1);",
      "      for (int j = 0; j < v; ++j) {",
      "        mint ajv = a[j + v];",
      "        a[j + v] = a[j] - ajv;",
      "        a[j] += ajv;",
      "      }",
      "    }",
      "    int u = 1 << (2 + (k & 1));",
      "    int v = 1 << (k - 2 - (k & 1));",
      "    mint one = mint(1);",
      "    mint imag = dw[1];",
      "    const __m128i m0 = _mm_set1_epi32(0);",
      "    const __m128i m1 = _mm_set1_epi32(mod);",
      "    const __m128i m2 = _mm_set1_epi32(mod + mod);",
      "    const __m128i r = _mm_set1_epi32(mint::r);",
      "    const __m128i Imag = _mm_set1_epi32(imag.a);",
      "    while (v) {",
      "      if (v == 1) {",
      "        mint ww = one, xx = one, wx = one;",
      "        for (int jh = 0; jh < u;) {",
      "          ww = xx * xx, wx = ww * xx;",
      "          mint t0 = a[jh + 0], t1 = a[jh + 1] * xx;",
      "          mint t2 = a[jh + 2] * ww, t3 = a[jh + 3] * wx;",
      "          mint t0p2 = t0 + t2, t1p3 = t1 + t3;",
      "          mint t0m2 = t0 - t2, t1m3 = (t1 - t3) * imag;",
      "          a[jh + 0] = t0p2 + t1p3, a[jh + 1] = t0p2 - t1p3;",
      "          a[jh + 2] = t0m2 + t1m3, a[jh + 3] = t0m2 - t1m3;",
      "          xx *= dw[__builtin_ctz((jh += 4))];",
      "        }",
      "      } else {",
      "        mint ww = one, xx = one, wx = one;",
      "        for (int jh = 0; jh < u;) {",
      "          if (jh == 0) {",
      "            int j0 = 0;",
      "            int j1 = v;",
      "            int j2 = j1 + v;",
      "            int j3 = j2 + v;",
      "            int je = v;",
      "            for (; j0 < je; j0 += 4, j1 += 4, j2 += 4, j3 += 4) {",
      "              __m128i T0 = _mm_loadu_si128((__m128i *)(a + j0));",
      "              __m128i T1 = _mm_loadu_si128((__m128i *)(a + j1));",
      "              __m128i T2 = _mm_loadu_si128((__m128i *)(a + j2));",
      "              __m128i T3 = _mm_loadu_si128((__m128i *)(a + j3));",
      "              __m128i T0P2 = montgomery_add(T0, T2, m2, m0);",
      "              __m128i T1P3 = montgomery_add(T1, T3, m2, m0);",
      "              __m128i T0M2 = montgomery_sub(T0, T2, m2, m0);",
      "              __m128i T1M3 =",
      "                  montgomery_mul(montgomery_sub(T1, T3, m2, m0), Imag, r, m1);",
      "              _mm_storeu_si128((__m128i *)(a + j0),",
      "                               montgomery_add(T0P2, T1P3, m2, m0));",
      "              _mm_storeu_si128((__m128i *)(a + j1),",
      "                               montgomery_sub(T0P2, T1P3, m2, m0));",
      "              _mm_storeu_si128((__m128i *)(a + j2),",
      "                               montgomery_add(T0M2, T1M3, m2, m0));",
      "              _mm_storeu_si128((__m128i *)(a + j3),",
      "                               montgomery_sub(T0M2, T1M3, m2, m0));",
      "            }",
      "          } else {",
      "            ww = xx * xx, wx = ww * xx;",
      "            __m128i WW = _mm_set1_epi32(ww.a);",
      "            __m128i WX = _mm_set1_epi32(wx.a);",
      "            __m128i XX = _mm_set1_epi32(xx.a);",
      "            int j0 = jh * v;",
      "            int j1 = j0 + v;",
      "            int j2 = j1 + v;",
      "            int j3 = j2 + v;",
      "            int je = j1;",
      "            for (; j0 < je; j0 += 4, j1 += 4, j2 += 4, j3 += 4) {",
      "              __m128i T0 = _mm_loadu_si128((__m128i *)(a + j0));",
      "              __m128i T1 = _mm_loadu_si128((__m128i *)(a + j1));",
      "              __m128i T2 = _mm_loadu_si128((__m128i *)(a + j2));",
      "              __m128i T3 = _mm_loadu_si128((__m128i *)(a + j3));",
      "              T1 = montgomery_mul(T1, XX, r, m1);",
      "              T2 = montgomery_mul(T2, WW, r, m1);",
      "              T3 = montgomery_mul(T3, WX, r, m1);",
      "              __m128i T0P2 = montgomery_add(T0, T2, m2, m0);",
      "              __m128i T1P3 = montgomery_add(T1, T3, m2, m0);",
      "              __m128i T0M2 = montgomery_sub(T0, T2, m2, m0);",
      "              __m128i T1M3 =",
      "                  montgomery_mul(montgomery_sub(T1, T3, m2, m0), Imag, r, m1);",
      "              _mm_storeu_si128((__m128i *)(a + j0),",
      "                               montgomery_add(T0P2, T1P3, m2, m0));",
      "              _mm_storeu_si128((__m128i *)(a + j1),",
      "                               montgomery_sub(T0P2, T1P3, m2, m0));",
      "              _mm_storeu_si128((__m128i *)(a + j2),",
      "                               montgomery_add(T0M2, T1M3, m2, m0));",
      "              _mm_storeu_si128((__m128i *)(a + j3),",
      "                               montgomery_sub(T0M2, T1M3, m2, m0));",
      "            }",
      "          }",
      "          xx *= dw[__builtin_ctz((jh += 4))];",
      "        }",
      "      }",
      "      u <<= 2;",
      "      v >>= 2;",
      "    }",
      "  }",
      "",
      "  constexpr void intt(mint *a, int n, int normalize = true) {",
      "    int k = n ? __builtin_ctz(n) : 0;",
      "    if (k == 0) return;",
      "    if (k == 1) {",
      "      mint a1 = a[1];",
      "      a[1] = a[0] - a[1];",
      "      a[0] = a[0] + a1;",
      "      return;",
      "    }",
      "    int u = 1 << (k - 2);",
      "    int v = 1;",
      "    mint one = mint(1);",
      "    mint imag = dy[1];",
      "    const __m128i m0 = _mm_set1_epi32(0);",
      "    const __m128i m1 = _mm_set1_epi32(mod);",
      "    const __m128i m2 = _mm_set1_epi32(mod + mod);",
      "    const __m128i r = _mm_set1_epi32(mint::r);",
      "    const __m128i Imag = _mm_set1_epi32(imag.a);",
      "    while (u) {",
      "      if (v == 1) {",
      "        mint ww = one, xx = one, yy = one;",
      "        u <<= 2;",
      "        for (int jh = 0; jh < u;) {",
      "          ww = xx * xx, yy = xx * imag;",
      "          mint t0 = a[jh + 0], t1 = a[jh + 1];",
      "          mint t2 = a[jh + 2], t3 = a[jh + 3];",
      "          mint t0p1 = t0 + t1, t2p3 = t2 + t3;",
      "          mint t0m1 = (t0 - t1) * xx, t2m3 = (t2 - t3) * yy;",
      "          a[jh + 0] = t0p1 + t2p3, a[jh + 2] = (t0p1 - t2p3) * ww;",
      "          a[jh + 1] = t0m1 + t2m3, a[jh + 3] = (t0m1 - t2m3) * ww;",
      "          xx *= dy[__builtin_ctz(jh += 4)];",
      "        }",
      "      } else {",
      "        mint ww = one, xx = one, yy = one;",
      "        u <<= 2;",
      "        for (int jh = 0; jh < u;) {",
      "          if (jh == 0) {",
      "            int j0 = 0;",
      "            int j1 = v;",
      "            int j2 = v + v;",
      "            int j3 = j2 + v;",
      "            for (; j0 < v; j0 += 4, j1 += 4, j2 += 4, j3 += 4) {",
      "              __m128i T0 = _mm_loadu_si128((__m128i *)(a + j0));",
      "              __m128i T1 = _mm_loadu_si128((__m128i *)(a + j1));",
      "              __m128i T2 = _mm_loadu_si128((__m128i *)(a + j2));",
      "              __m128i T3 = _mm_loadu_si128((__m128i *)(a + j3));",
      "              __m128i T0P1 = montgomery_add(T0, T1, m2, m0);",
      "              __m128i T2P3 = montgomery_add(T2, T3, m2, m0);",
      "              __m128i T0M1 = montgomery_sub(T0, T1, m2, m0);",
      "              __m128i T2M3 =",
      "                  montgomery_mul(montgomery_sub(T2, T3, m2, m0), Imag, r, m1);",
      "              _mm_storeu_si128((__m128i *)(a + j0),",
      "                               montgomery_add(T0P1, T2P3, m2, m0));",
      "              _mm_storeu_si128((__m128i *)(a + j2),",
      "                               montgomery_sub(T0P1, T2P3, m2, m0));",
      "              _mm_storeu_si128((__m128i *)(a + j1),",
      "                               montgomery_add(T0M1, T2M3, m2, m0));",
      "              _mm_storeu_si128((__m128i *)(a + j3),",
      "                               montgomery_sub(T0M1, T2M3, m2, m0));",
      "            }",
      "          } else {",
      "            ww = xx * xx, yy = xx * imag;",
      "            __m128i WW = _mm_set1_epi32(ww.a);",
      "            __m128i XX = _mm_set1_epi32(xx.a);",
      "            __m128i YY = _mm_set1_epi32(yy.a);",
      "            int j0 = jh * v;",
      "            int j1 = j0 + v;",
      "            int j2 = j1 + v;",
      "            int j3 = j2 + v;",
      "            int je = j1;",
      "            for (; j0 < je; j0 += 4, j1 += 4, j2 += 4, j3 += 4) {",
      "              __m128i T0 = _mm_loadu_si128((__m128i *)(a + j0));",
      "              __m128i T1 = _mm_loadu_si128((__m128i *)(a + j1));",
      "              __m128i T2 = _mm_loadu_si128((__m128i *)(a + j2));",
      "              __m128i T3 = _mm_loadu_si128((__m128i *)(a + j3));",
      "              __m128i T0P1 = montgomery_add(T0, T1, m2, m0);",
      "              __m128i T2P3 = montgomery_add(T2, T3, m2, m0);",
      "              __m128i T0M1 =",
      "                  montgomery_mul(montgomery_sub(T0, T1, m2, m0), XX, r, m1);",
      "              __m128i T2M3 =",
      "                  montgomery_mul(montgomery_sub(T2, T3, m2, m0), YY, r, m1);",
      "              _mm_storeu_si128((__m128i *)(a + j0),",
      "                               montgomery_add(T0P1, T2P3, m2, m0));",
      "              _mm_storeu_si128(",
      "                  (__m128i *)(a + j2),",
      "                  montgomery_mul(montgomery_sub(T0P1, T2P3, m2, m0), WW, r,",
      "                                 m1));",
      "              _mm_storeu_si128((__m128i *)(a + j1),",
      "                               montgomery_add(T0M1, T2M3, m2, m0));",
      "              _mm_storeu_si128(",
      "                  (__m128i *)(a + j3),",
      "                  montgomery_mul(montgomery_sub(T0M1, T2M3, m2, m0), WW, r,",
      "                                 m1));",
      "            }",
      "          }",
      "          xx *= dy[__builtin_ctz(jh += 4)];",
      "        }",
      "      }",
      "      u >>= 4;",
      "      v <<= 2;",
      "    }",
      "    if (k & 1) {",
      "      u = 1 << (k - 1);",
      "      for (int j = 0; j < u; ++j) {",
      "        mint ajv = a[j] - a[j + u];",
      "        a[j] += a[j + u];",
      "        a[j + u] = ajv;",
      "      }",
      "    }",
      "    if (normalize) {",
      "      mint invn = one / mint(n);",
      "      for (int i = 0; i < n; i++) a[i] *= invn;",
      "    }",
      "  }",
      "",
      "  constexpr vector<mint> multiply(const vector<mint> &a,",
      "                                  const vector<mint> &b) {",
      "    int l = a.size() + b.size() - 1;",
      "    if (min<int>(a.size(), b.size()) <= 40) {",
      "      vector<mint> s(l);",
      "      for (int i = 0; i < (int)a.size(); ++i)",
      "        for (int j = 0; j < (int)b.size(); ++j) s[i + j] += a[i] * b[j];",
      "      return s;",
      "    }",
      "    int M = 4;",
      "    while (M < l) M <<= 1;",
      "    for (int i = 0; i < (int)a.size(); ++i) buf1[i].a = a[i].a;",
      "    for (int i = 0; i < (int)b.size(); ++i) buf2[i].a = b[i].a;",
      "    ntt(buf1, M);",
      "    ntt(buf2, M);",
      "    for (int i = 0; i < M; ++i)",
      "      buf1[i].a = mint::reduce(u64(buf1[i].a) * buf2[i].a);",
      "    intt(buf1, M, false);",
      "    vm s(l);",
      "    mint invm = mint(M).inverse();",
      "    for (int i = 0; i < l; ++i) s[i] = buf1[i] * invm;",
      "    return s;",
      "  }",
      "};"
    ],
    "description": "NTT_using_SIMD"
  }
}